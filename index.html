<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>33聊天模拟器</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Long+Cang&display=swap" rel="stylesheet">
    <!-- 引入新增的Google Fonts字体 -->
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&family=ZCOOL+KuaiLe&family=ZCOOL+QingKe+HuangYou&family=Liu+Jian+Mao+Cao&family=Zhi+Mang+Xing&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet">
<style>
        /* 引入Zpix像素字体 */
        @font-face {
            font-family: 'Zpix';
            src: url('https://cdn.jsdelivr.net/gh/SolidZORO/zpix-pixel-font@master/dist/zpix.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        /* 定义随笔字体和心声字体变量，以便通过JavaScript动态更改 */
        :root {
            --essay-font-family: 'Ma Shan Zheng', cursive, sans-serif; /* 默认随笔字体 */
            --inner-voice-font-family: 'Ma Shan Zheng', cursive, sans-serif; /* 默认心声字体 */

            /* 定义主题颜色变量 - 默认主题 (粉绿米蓝) */
            --theme-color-1: #EDD4D8; /* 主题色1 */
            --theme-color-2: #CCD4CC; /* 主题色2 */
            --theme-color-3: #F4E8DD; /* 主题色3 */
            --theme-color-4: #B5BFCF; /* 主题色4 */

            /* RGB版本的主题色，用于rgba() */
            --theme-color-rgb-1: 237, 212, 216; /* EDD4D8 */
            --theme-color-rgb-2: 204, 212, 204; /* CCD4CC */
            --theme-color-rgb-3: 244, 232, 221; /* F4E8DD */
            --theme-color-rgb-4: 181, 191, 207; /* B5BFCF */

            /* 辅助颜色变量，可随主题调整 */
            --text-color-dark: #333;
            --text-color-medium: #555;
            --text-color-light: #666;
            --text-color-lighter: #999;
            --text-color-white: white; /* 确保白色文本 */

            --header-text-shadow-color: rgba(255, 255, 255, 0.7);
            --status-dot-online: #4CAF50;
            --status-dot-busy: #FFC107;
            --status-dot-offline: #9E9E9E;

            --btn-bg: rgba(255, 255, 255, 0.7);
            --btn-hover-bg: white;
            --btn-icon-color: #555;

            --message-received-bubble-bg: white;
            --message-sent-bubble-text-color: white; /* 修正：玩家气泡字体颜色 */

            --retracted-bubble-bg: #FFF0F0;
            --retracted-bubble-border: #FF6347;
            --auto-reply-bubble-bg: #E0F2F7;
            --auto-reply-bubble-border: #87CEEB;
            --auto-reply-label-bg: #D0EEF5;

            --input-area-bg: white;
            --toggle-input-btn-bg: rgba(255, 255, 255, 0.7);
            --toggle-input-btn-hover-bg: white;
            --toggle-input-btn-icon-color: #555;

            --modal-title-color: #333;
            --close-btn-color: #555;
            --form-label-color: #555;
            --upload-btn-color: white;
            --btn-primary-color: white;

            --inner-voice-color: #FF69B4;
            --inner-voice-bg: #FFF0F5;
            --inner-voice-shadow-rgb: 255, 105, 180;

            --essay-text-color: #444;
            --essay-bg: #FFFACD;
            --essay-border: #E0C068;
            --essay-pin-color: #FFD700;

            --toggle-switch-off-bg: #f0f0f0;
            --toggle-switch-border: #ccc;
            --toggle-switch-handle-bg: white;

            --event-message-bg: rgba(128, 128, 128, 0.1);
            --event-message-color: #555;

            --persona-card-bg-light: #f9f9f9;
            --persona-card-border-light: #eee;

            --moment-input-bg-light: #f0f0f0;
            --moment-input-border-light: #ddd;
            --moment-card-bg-light: #fff;
            --moment-card-border-light: #eee;
            --moment-image-preview-bg: #f9f9f9;
            --moment-name-color: #333;
            --moment-content-color: #444;
            --moment-comments-border: #f0f0f0;
            --moment-comments-title-color: #666;
            --comment-bg-light: #f5f5f5;
            --comment-text-color: #333;
            --comment-timestamp-color: #999;

            --regenerate-modal-title-color: #444;
            --regenerate-modal-body-color: #555;
            --regenerate-modal-body-small-color: #888;

            /* 通用阴影和边框颜色，保持中性 */
            --border-color-light: rgba(0, 0, 0, 0.1);
            --shadow-color-light: rgba(0, 0, 0, 0.1);
            --shadow-color-medium: rgba(0, 0, 0, 0.15);
            --shadow-color-dark: rgba(0, 0, 0, 0.2);

            /* 动态背景和渐变，使用主题色变量 */
            --body-bg-gradient: linear-gradient(135deg, var(--theme-color-1), var(--theme-color-2), var(--theme-color-3), var(--theme-color-4));
            --header-bg-gradient: linear-gradient(to right, var(--theme-color-1), var(--theme-color-4));
            --message-received-bubble-border-dynamic: var(--theme-color-1);
            --message-sent-bubble-bg-gradient: linear-gradient(to right, var(--theme-color-2), var(--theme-color-4));
            --message-input-border-dynamic: var(--theme-color-1);
            --message-input-bg-alpha: rgba(var(--theme-color-rgb-1), 0.1);
            --message-input-focus-border-dynamic: var(--theme-color-4);
            --message-input-focus-shadow-color: rgba(var(--theme-color-rgb-4), 0.3);
            --send-btn-bg-gradient: linear-gradient(to right, var(--theme-color-1), var(--theme-color-4));
            --modal-header-bg-gradient: linear-gradient(to right, var(--theme-color-1), var(--theme-color-4));
            --form-control-border-dynamic: var(--theme-color-1);
            --form-control-bg-alpha: rgba(var(--theme-color-rgb-1), 0.1);
            --form-control-focus-border-dynamic: var(--theme-color-4);
            --form-control-focus-shadow-color: rgba(var(--theme-color-rgb-4), 0.3);
            --avatar-preview-border-dynamic: white;
            --upload-btn-bg-gradient: linear-gradient(to right, var(--theme-color-1), var(--theme-color-4));
            --btn-primary-bg-gradient: linear-gradient(to right, var(--theme-color-1), var(--theme-color-4));
            --btn-secondary-border-dynamic: var(--theme-color-1);
            --toggle-switch-checked-bg-dynamic: var(--theme-color-4);
            --toggle-switch-checked-border-dynamic: var(--theme-color-4);
            --toggle-switch-inner-checked-bg-dynamic: var(--theme-color-4);
            --essay-notification-bg-gradient: linear-gradient(to right, var(--theme-color-4), var(--theme-color-1));
            --manage-modal-btn-bg-alpha: rgba(var(--theme-color-rgb-1), 0.5);
            --manage-modal-btn-hover-bg-alpha: rgba(var(--theme-color-rgb-1), 0.8);
            --persona-card-avatar-border-dynamic: var(--theme-color-4);
            --regenerate-modal-header-bg-gradient: linear-gradient(to right, var(--theme-color-3), var(--theme-color-1));
        
            /* 新增：聊天背景设置变量 */
            --chat-background-image: none; /* 默认：无背景图 */
            --chat-background-size: cover;
            --chat-background-position: center;
            --chat-background-repeat: no-repeat;
            --chat-background-attachment: fixed; /* 核心修改：背景图固定，不随内容滚动 */
            --chat-background-overlay-color: rgba(255, 255, 255, 0.85); /* 聊天区域背景叠加色，保持半透明效果 */

            /* 新增：输入栏上移高度变量 */
            --input-area-shift-height: 0px; /* 默认不偏移 */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "SimSun", "宋体", serif;
        }
        
        body {
            background: var(--body-bg-gradient);
            height: 100vh;
            overflow: hidden;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-color-dark);
        }
        
        .container {
            width: 100%;
            max-width: 500px;
            height: 90vh;
            /* 将原有的半透明背景改为纯白，以便聊天区域的背景图能更好地显示 */
            background: white; 
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        /* 顶部标题栏 */
        .header {
            background: var(--header-bg-gradient);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color-light);
            z-index: 10;
        }
        
        .header h1 {
            font-size: 1.4rem;
            color: var(--text-color-dark);
            text-shadow: 1px 1px 2px var(--header-text-shadow-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* 新增：状态点样式 */
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            border: 1px solid var(--border-color-light);
            box-shadow: 0 1px 3px var(--shadow-color-light);
        }

        .status-dot.online {
            background-color: var(--status-dot-online);
        }

        .status-dot.busy {
            background-color: var(--status-dot-busy);
        }

        .status-dot.offline {
            background-color: var(--status-dot-offline);
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            background: var(--btn-bg);
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px var(--shadow-color-light);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px var(--shadow-color-medium);
            background: var(--btn-hover-bg);
        }
        
        .btn i {
            font-size: 1rem;
            color: var(--btn-icon-color);
        }
        
        /* 聊天区域 */
        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            /* 应用背景图片和叠加色 */
            background-image: var(--chat-background-image);
            background-size: var(--chat-background-size);
            background-position: var(--chat-background-position);
            background-repeat: var(--chat-background-repeat);
            background-attachment: var(--chat-background-attachment);
            background-color: var(--chat-background-overlay-color); /* 叠加在图片上，提供半透明效果 */
        }
        
        /* 消息样式 */
        .message {
            display: flex;
            max-width: 80%;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .message.received {
            align-self: flex-start;
        }
        
        .message.sent {
            align-self: flex-end;
        }
        
        .avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--text-color-white);
            box-shadow: 0 2px 5px var(--shadow-color-light);
            flex-shrink: 0;
        }
        
        .message.received .avatar {
            margin-right: 10px;
        }
        
        .message.sent .avatar {
            margin-left: 10px;
            order: 2;
        }
        
        .message-content {
            display: flex;
            flex-direction: column;
        }
        
        .message.received .message-content {
            align-items: flex-start;
        }
        
        .message.sent .message-content {
            align-items: flex-end;
        }
        
        .name {
            font-size: 0.8rem;
            color: var(--text-color-light);
            margin-bottom: 5px;
        }
        
        .bubble {
            padding: 12px 16px;
            border-radius: 18px;
            position: relative;
            word-break: break-word;
            line-height: 1.4;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .message.received .bubble {
            background: var(--message-received-bubble-bg);
            border: 1px solid var(--message-received-bubble-border-dynamic);
            border-top-left-radius: 5px;
        }
        
        .message.sent .bubble {
            background: var(--message-sent-bubble-bg-gradient);
            color: var(--message-sent-bubble-text-color);
            border-top-right-radius: 5px;
        }
        
        /* 新增：撤回消息气泡样式 */
        .message.received .bubble.retracted-bubble {
            background: var(--retracted-bubble-bg);
            border: 1px dashed var(--retracted-bubble-border);
            color: var(--text-color-medium);
        }

        /* 新增：自动回复消息气泡样式 */
        .message.received .bubble.auto-reply-bubble {
            background: var(--auto-reply-bubble-bg);
            border: 1px dashed var(--auto-reply-bubble-border);
            color: var(--text-color-dark);
        }

        /* 新增：表情包气泡样式 */
        .bubble.emoji-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
            max-width: 135px;
            height: auto;
        }

        .bubble.emoji-bubble img {
            max-width: 120px;
            max-height: 120px;
            object-fit: contain; 
            border-radius: 10px;
            box-shadow: 0 2px 5px var(--shadow-color-light);
        }

        .timestamp {
            font-size: 0.7rem;
            color: var(--text-color-lighter);
            margin-top: 5px;
            text-align: right;
            display: flex;
            align-items: center;
            gap: 5px;
            justify-content: flex-end;
        }

        /* 自动回复标签 */
        .auto-reply-label {
            font-size: 0.65rem;
            color: var(--text-color-light);
            background: var(--auto-reply-label-bg);
            padding: 2px 6px;
            border-radius: 8px;
            white-space: nowrap;
        }

        /* 自动回复消息的时间戳样式 */
        .message.received .message-content .timestamp {
            justify-content: flex-start;
            margin-left: 0;
            margin-top: 5px;
            margin-bottom: 0;
        }
        
        /* 输入区域 */
        .input-area {
            background: var(--input-area-bg);
            padding: 15px 20px;
            border-top: 1px solid var(--border-color-light);
            display: flex;
            gap: 10px;
            z-index: 10;
            align-items: flex-end;
            /* 新增：根据变量调整底部外边距，实现上移效果 */
            margin-bottom: var(--input-area-shift-height); 
            transition: margin-bottom 0.3s ease; /* 平滑过渡 */
        }
        
        .message-input {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid var(--message-input-border-dynamic);
            border-radius: 25px;
            outline: none;
            font-size: 1rem;
            transition: height 0.3s ease-out;
            background: var(--message-input-bg-alpha);
            height: 50px;
            min-height: 50px;
            max-height: 150px;
            resize: none;
            overflow-y: hidden;
            line-height: 1.4;
            padding-top: 15px;
            padding-bottom: 15px;
        }
        
        .message-input:focus {
            border-color: var(--message-input-focus-border-dynamic);
            box-shadow: 0 0 0 2px var(--message-input-focus-shadow-color);
            outline: none;
        }

        .message-input.expanded {
            height: 150px;
            overflow-y: auto;
        }
        
        .send-btn {
            background: var(--send-btn-bg-gradient);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px var(--shadow-color-medium);
            flex-shrink: 0;
        }
        
        .send-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 12px var(--shadow-color-dark);
        }
        
        .send-btn i {
            font-size: 1.4rem;
            color: var(--btn-primary-color); /* 使用主按钮颜色变量 */
        }

        /* 展开/收起按钮样式 */
        .toggle-input-btn {
            background: var(--toggle-input-btn-bg);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px var(--shadow-color-medium);
            flex-shrink: 0;
        }

        .toggle-input-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 12px var(--shadow-color-dark);
            background: var(--toggle-input-btn-hover-bg);
        }

        .toggle-input-btn .arrow-icon {
            font-size: 1rem;
            color: var(--toggle-input-btn-icon-color);
            line-height: 1;
        }
        
        /* 自定义弹窗 */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .modal.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-content {
            background: var(--text-color-white);
            border-radius: 20px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            background: var(--modal-header-bg-gradient);
            padding: 20px;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 1.4rem;
            color: var(--modal-title-color);
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--close-btn-color);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .close-btn:hover {
            transform: rotate(90deg);
            color: var(--text-color-dark);
        }
        
        .modal-body {
            padding: 25px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--form-label-color);
        }
        
        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--form-control-border-dynamic);
            border-radius: 12px;
            font-size: 1rem;
            background: var(--form-control-bg-alpha);
            transition: all 0.3s ease;
        }
        
        .form-control:focus {
            border-color: var(--form-control-focus-border-dynamic);
            box-shadow: 0 0 0 2px var(--form-control-focus-shadow-color);
            outline: none;
        }
        
        .avatar-upload {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .avatar-preview {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid var(--avatar-preview-border-dynamic);
            box-shadow: 0 5px 15px var(--shadow-color-light);
            margin-bottom: 15px;
            background: #f0f0f0;
        }
        
        .upload-btn {
            background: var(--upload-btn-bg-gradient);
            color: var(--upload-btn-color);
            border: none;
            border-radius: 25px;
            padding: 10px 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px var(--shadow-color-medium);
        }
        
        .upload-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 12px var(--shadow-color-dark);
        }
        
        .modal-footer {
            padding: 20px;
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            border-top: 1px solid var(--border-color-light);
        }
        
        .btn-primary {
            background: var(--btn-primary-bg-gradient);
            color: var(--btn-primary-color);
            border: none;
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px var(--shadow-color-medium);
        }
        
        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 12px var(--shadow-color-dark);
        }
        
        .btn-secondary {
            background: var(--text-color-white);
            color: var(--text-color-medium);
            border: 1px solid var(--btn-secondary-border-dynamic);
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-secondary:hover {
            background: #f9f9f9;
            transform: translateY(-3px);
            box-shadow: 0 3px 8px var(--shadow-color-light);
        }
        
        /* 特效 */
        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0);
            pointer-events: none;
            animation: rippleEffect 0.8s linear;
        }
        
        @keyframes rippleEffect {
            to {
                transform: scale(2.5);
                opacity: 0;
            }
        }
        
        .star {
            position: absolute;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            animation: starEffect 1.2s ease-out;
            opacity: 0.7;
        }
        
        @keyframes starEffect {
            0% {
                transform: translate(0, 0) scale(0);
                opacity: 0.7;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(1);
                opacity: 0;
            }
        }
        
        /* 加载指示器 */
        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background: var(--text-color-white);
            border: 1px solid var(--message-received-bubble-border-dynamic);
            border-radius: 18px;
            max-width: 100px;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .typing-indicator span {
            width: 8px;
            height: 8px;
            background: var(--theme-color-4);
            border-radius: 50%;
            display: inline-block;
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }
        
        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-5px);
            }
        }

        /* 心声文本样式 */
        .inner-voice-text {
            font-family: var(--inner-voice-font-family);
            font-size: 1.2rem;
            color: var(--inner-voice-color);
            text-align: center;
            padding: 10px;
            line-height: 1.6;
            background: var(--inner-voice-bg);
            border-radius: 15px;
            box-shadow: inset 0 0 8px rgba(var(--inner-voice-shadow-rgb), 0.2);
        }

        /* 随笔文本样式，现在使用CSS变量来控制字体 */
        .essay-text {
            font-family: var(--essay-font-family);
            font-size: 1.1rem;
            color: var(--essay-text-color);
            text-align: left;
            padding: 15px;
            line-height: 1.6;
            background: var(--essay-bg);
            border: 1px solid var(--essay-border);
            border-radius: 8px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
            margin-top: 20px;
            white-space: pre-wrap;
        }

        /* 随笔的“图钉”效果 */
        .essay-text::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 15px;
            width: 20px;
            height: 20px;
            background: var(--essay-pin-color);
            border-radius: 50%;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.3);
            transform: rotate(45deg);
        }

        /* 新增：气泡和撤回标记的容器 */
        .bubble-and-tag-wrapper {
            display: flex;
            align-items: flex-end;
            gap: 5px;
            max-width: 100%;
        }

        /* 新增：撤回标记样式 */
        .retracted-tag {
            font-size: 0.75rem;
            color: var(--text-color-lighter);
            white-space: nowrap;
            flex-shrink: 0;
            margin-bottom: 2px;
        }

        /* Toggle Switch Styles */
        .toggle-switch-container {
            position: relative;
            width: 60px;
            height: 34px;
            margin-top: 10px;
        }

        .toggle-switch-checkbox {
            display: none;
        }

        .toggle-switch-label {
            display: block;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid var(--toggle-switch-border);
            border-radius: 34px;
            background-color: var(--toggle-switch-off-bg);
            transition: background-color 0.3s ease;
        }

        .toggle-switch-checkbox:checked + .toggle-switch-label {
            background-color: var(--toggle-switch-checked-bg-dynamic);
            border-color: var(--toggle-switch-checked-border-dynamic);
        }

        .toggle-switch-inner {
            display: block;
            width: 200%;
            margin-left: -100%;
            transition: margin-left 0.3s ease;
        }

        .toggle-switch-inner:before, .toggle-switch-inner:after {
            float: left;
            width: 50%;
            height: 30px;
            padding: 0;
            line-height: 30px;
            font-size: 14px;
            color: var(--text-color-white);
            font-weight: bold;
            box-sizing: border-box;
        }

        .toggle-switch-inner:before {
            content: "开";
            padding-left: 10px;
            background-color: var(--toggle-switch-inner-checked-bg-dynamic);
            color: var(--text-color-white);
        }

        .toggle-switch-inner:after {
            content: "关";
            padding-right: 10px;
            background-color: var(--toggle-switch-off-bg);
            color: var(--text-color-lighter);
            text-align: right;
        }

        .toggle-switch-switch {
            display: block;
            width: 26px;
            height: 26px;
            margin: 2px;
            background: var(--toggle-switch-handle-bg);
            position: absolute;
            top: 0;
            bottom: 0;
            right: 28px;
            border: 2px solid var(--toggle-switch-border);
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch-checkbox:checked + .toggle-switch-label .toggle-switch-inner {
            margin-left: 0;
        }

        .toggle-switch-checkbox:checked + .toggle-switch-label .toggle-switch-switch {
            right: 0px;
            background: var(--toggle-switch-handle-bg);
            border-color: var(--toggle-switch-checked-border-dynamic);
        }

        /* New style for poke messages (event notifications) */
        .message.event-message {
            align-self: center;
            max-width: 70%;
            background: var(--event-message-bg);
            color: var(--event-message-color);
            border-radius: 10px;
            padding: 8px 15px;
            text-align: center;
            font-size: 0.9rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            margin-top: 10px;
            margin-bottom: 10px;
            animation: fadeIn 0.3s ease;
        }

        .message.event-message .message-content {
            display: block;
            width: 100%;
        }

        .message.event-message .bubble {
            background: none;
            border: none;
            padding: 0;
            box-shadow: none;
            color: inherit;
        }

        .message.event-message .name,
        .message.event-message .avatar,
        .message.event-message .timestamp,
        .message.event-message .retracted-tag,
        .message.event-message .auto-reply-label {
            display: none;
        }
        
        /* 新增：随笔通知浮窗样式 */
        .essay-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            background: var(--essay-notification-bg-gradient);
            color: var(--text-color-white);
            padding: 12px 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease-out;
            min-width: 250px;
            text-align: center;
            font-size: 0.95rem;
        }

        .essay-notification.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        /* 新增：管理侧边弹窗样式 */
        .manage-modal {
            position: fixed;
            top: 0;
            right: 0;
            width: 100%;
            max-width: 320px;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.2);
            z-index: 1050;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .manage-modal.active {
            transform: translateX(0);
        }

        .manage-modal .modal-header {
            border-radius: 0;
            padding: 15px 20px;
        }

        .manage-modal .modal-body {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .manage-modal .modal-body .btn {
            width: 100%;
            height: 50px;
            border-radius: 10px;
            font-size: 1.1rem;
            color: var(--text-color-dark);
            background: var(--manage-modal-btn-bg-alpha);
            box-shadow: 0 2px 5px var(--shadow-color-light);
            display: flex;
            justify-content: flex-start;
            padding-left: 20px;
            gap: 15px;
        }

        .manage-modal .modal-body .btn i {
            font-size: 1.2rem;
            color: var(--text-color-medium);
        }

        .manage-modal .modal-body .btn span {
            flex-grow: 1;
            text-align: left;
        }

        .manage-modal .modal-body .btn:hover {
            background: var(--manage-modal-btn-hover-bg-alpha);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color-medium);
        }

        /* 新增：人设选择弹窗内的卡片样式 */
        .persona-selection-card { /* 新增类名，专用于人设选择卡片 */
            background: var(--persona-card-bg-light);
            border: 1px solid var(--persona-card-border-light);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px; /* 保持卡片间距 */
            display: flex;
            flex-direction: column; /* 垂直堆叠内容 */
            align-items: center; /* 水平居中内容 */
            text-align: center; /* 文本居中 */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .persona-selection-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.12);
        }

        .persona-selection-card .avatar-preview {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--persona-card-avatar-border-dynamic);
            box-shadow: 0 1px 3px var(--shadow-color-light);
            margin-bottom: 10px; /* 头像下方留出间距 */
        }

        .persona-selection-card .persona-name-display { /* 新增类名，专用于人设名字 */
            font-size: 1.2rem;
            color: var(--text-color-dark);
            margin-bottom: 5px; /* 名字下方留出间距 */
            font-weight: bold; /* 名字加粗 */
        }

        .persona-selection-card p {
            font-size: 0.9rem;
            color: var(--text-color-light);
            margin-bottom: 15px;
            line-height: 1.4;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .persona-selection-card-actions { /* 新增类名，专用于人设卡片动作按钮容器 */
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }

        .persona-selection-card-actions .btn-secondary,
        .persona-selection-card-actions .btn-primary {
            padding: 8px 15px;
            font-size: 0.9rem;
            border-radius: 20px;
            flex: 1;
        }

        /* 调整详情弹窗的样式，使其更紧凑 */
        #persona-detail-modal .modal-body {
            padding: 20px;
        }

        #persona-detail-modal .form-group {
            margin-bottom: 10px;
        }

        #persona-detail-modal .form-group label {
            font-size: 0.9rem;
            margin-bottom: 3px;
            color: #777;
        }

        #persona-detail-modal .form-group p {
            font-size: 1rem;
            color: var(--text-color-dark);
            background: var(--moment-input-bg-light);
            padding: 8px 12px;
            border-radius: 8px;
            word-break: break-word;
        }

        #persona-detail-modal .avatar-preview {
            width: 100px;
            height: 100px;
            margin-bottom: 15px;
        }

        /* 新增：朋友圈弹窗样式 */
        #moments-modal .modal-content {
            max-width: 600px;
        }

        .post-moment-area {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--persona-card-border-light);
        }

        .post-moment-area .form-control {
            min-height: 80px;
            resize: vertical;
        }

        .post-moment-area .upload-btn,
        .post-moment-area .btn-primary {
            align-self: flex-end;
            width: auto;
            padding: 8px 18px;
            font-size: 0.9rem;
        }

        .post-moment-area .upload-btn {
            background: var(--moment-input-bg-light);
            color: var(--text-color-medium);
            border: 1px solid var(--moment-input-border-light);
            box-shadow: none;
        }
        .post-moment-area .upload-btn:hover {
            background: #e0e0e0;
            transform: none;
            box-shadow: none;
        }

        .moment-image-preview-container {
            position: relative;
            width: 120px;
            height: 120px;
            border: 1px solid var(--moment-input-border-light);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 10px;
            background-color: var(--moment-image-preview-bg);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .moment-image-preview {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .remove-image-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: var(--text-color-white);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .remove-image-btn:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        .latest-moment-display h4 {
            font-size: 1.1rem;
            color: var(--text-color-medium);
            margin-bottom: 15px;
            text-align: center;
        }

        .moment-card {
            background: var(--moment-card-bg-light);
            border: 1px solid var(--moment-card-border-light);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
        }

        .moment-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .moment-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
            border: 2px solid var(--text-color-white);
            box-shadow: 0 1px 3px var(--shadow-color-light);
        }

        .moment-name {
            font-weight: bold;
            color: var(--moment-name-color);
            font-size: 1rem;
        }

        .moment-timestamp {
            font-size: 0.8rem;
            color: var(--comment-timestamp-color); /* 使用评论时间戳颜色 */
            margin-left: auto;
        }

        .moment-content p {
            font-size: 1rem;
            color: var(--moment-content-color);
            line-height: 1.5;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }

        .moment-photo {
            max-width: 100%;
            border-radius: 10px;
            margin-top: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .moment-comments {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--moment-comments-border);
        }

        .moment-comments h5 {
            font-size: 0.95rem;
            color: var(--moment-comments-title-color);
            margin-bottom: 10px;
        }

        .comment-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .comment-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .comment-text-container {
            background: var(--comment-bg-light);
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 0.9rem;
            color: var(--comment-text-color);
            word-break: break-word;
            flex-grow: 1;
        }

        .comment-timestamp {
            font-size: 0.75rem;
            color: var(--comment-timestamp-color);
            margin-left: 5px;
        }

        /* 新增：重新生成弹窗样式 */
        .regenerate-modal-content {
            background: var(--text-color-white);
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .regenerate-modal-content .modal-header {
            background: var(--regenerate-modal-header-bg-gradient);
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
            padding: 15px 20px;
        }

        .regenerate-modal-content .modal-title {
            font-size: 1.2rem;
            color: var(--regenerate-modal-title-color);
        }

        .regenerate-modal-content .modal-body {
            padding: 20px;
            text-align: center;
            font-size: 1rem;
            color: var(--regenerate-modal-body-color);
        }

        .regenerate-modal-content .modal-body p small {
            color: var(--regenerate-modal-body-small-color);
        }

        .regenerate-modal-content .modal-footer {
            padding: 15px 20px;
            justify-content: center;
            gap: 15px;
        }

        /* 主题选择器中的颜色预览 */
        .theme-options-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }

        .theme-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            border-radius: 10px;
            border: 2px solid transparent; /* 默认透明边框 */
            transition: border-color 0.3s ease;
        }

        .theme-option.selected {
            border-color: var(--theme-color-4); /* 选中时使用主题色4作为边框 */
        }

        .theme-option .color-swatch {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin-bottom: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .theme-option span {
            font-size: 0.9rem;
            color: var(--text-color-dark);
        }
        
        /* 新增：星空紫罗兰主题下玩家气泡的边框 */
        body.theme-starry-violet .message.sent .bubble {
            border: 1px solid rgba(var(--theme-color-rgb-4), 0.6);
        }

        /* 新增：背景设置区域样式 */
        .background-options-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .background-upload-section, .default-background-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 15px;
            border: 1px dashed var(--border-color-light);
            border-radius: 10px;
            background: var(--moment-input-bg-light); /* 复用一个浅色背景变量 */
        }

        .background-preview {
            width: 150px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color-light);
            box-shadow: 0 2px 5px var(--shadow-color-light);
        }

        .background-upload-section .upload-btn,
        .background-upload-section .btn-secondary {
            width: auto;
            padding: 8px 18px;
            font-size: 0.9rem;
        }

        .background-upload-section .upload-btn {
            background: var(--moment-input-bg-light);
            color: var(--text-color-medium);
            border: 1px solid var(--moment-input-border-light);
            box-shadow: none;
        }
        .background-upload-section .upload-btn:hover {
            background: #e0e0e0;
            transform: none;
            box-shadow: none;
        }

        .default-background-section select {
            width: 100%;
        }

        /* 新增：本地记录弹窗内的卡片样式 */
        .local-records-list-container {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Spacing between cards */
        }

        .save-slot-card {
            background: var(--persona-card-bg-light); /* Reusing persona card background */
            border: 1px solid var(--persona-card-border-light);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .save-slot-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.12);
        }

        .save-slot-card h4 {
            font-size: 1.1rem;
            color: var(--text-color-dark);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .save-slot-card .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--persona-card-avatar-border-dynamic);
            box-shadow: 0 1px 3px var(--shadow-color-light);
            flex-shrink: 0;
        }

        .save-slot-card .slot-info {
            flex-grow: 1;
        }

        .save-slot-card .slot-name {
            font-weight: bold;
            color: var(--text-color-dark);
        }

        .save-slot-card .slot-time {
            font-size: 0.8rem;
            color: var(--text-color-lighter);
            margin-top: 5px;
        }

        .save-slot-card .latest-messages {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            background: var(--moment-input-bg-light);
            padding: 8px 12px;
            border-radius: 8px;
            max-height: 80px; /* Limit height for preview */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 4; /* Show max 4 lines */
            -webkit-box-orient: vertical;
            white-space: pre-wrap; /* Preserve whitespace for messages */
        }

        .save-slot-card .slot-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: flex-end; /* Align buttons to the right */
        }

        .save-slot-card .slot-actions .btn-primary,
        .save-slot-card .slot-actions .btn-secondary {
            padding: 8px 15px;
            font-size: 0.9rem;
            border-radius: 20px;
            flex: 1; /* Distribute space evenly */
        }

        .save-slot-card.empty-slot {
            text-align: center;
            padding: 30px;
            color: var(--text-color-lighter);
            font-style: italic;
            justify-content: center;
            align-items: center;
        }

        .save-slot-card.empty-slot .slot-actions {
            justify-content: center;
        }

        /* 适配小屏幕 */
        @media (max-width: 500px) {
            .container {
                height: 100vh;
                border-radius: 0;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
            
            .bubble {
                padding: 10px 14px;
                font-size: 0.95rem;
            }
            
            .message-input {
                padding: 10px 15px;
            }
            
            .send-btn {
                width: 45px;
                height: 45px;
            }

            .toggle-input-btn {
                width: 45px;
                height: 45px;
            }

            .essay-notification {
                width: 90%;
                left: 5%;
                transform: translateX(0) translateY(-100%);
            }
            .essay-notification.show {
                transform: translateX(0) translateY(0);
            }

            .manage-modal {
                width: 100%;
                max-width: none;
            }

            /* 手机端输入栏上移高度调整 */
            .container.input-area-shifted-up {
                --input-area-shift-height: 60px; /* 手机导航栏通常较高 */
            }
        }

        /* 桌面端输入栏上移高度调整 */
        .container.input-area-shifted-up {
            --input-area-shift-height: 50px; /* 默认上移高度 */
        }
        
        
        /* Card Message Specific Styles */
        .message .card-bubble {
            background-color: var(--message-received-bubble-bg); /* 卡片背景色，通常与接收消息气泡背景一致 */
            border-radius: 12px; /* 圆角 */
            padding: 0; /* 移除默认气泡内边距，由卡片内部元素控制 */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* 确保内容在圆角内被裁剪 */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); /* 轻微阴影 */
            max-width: 280px; /* 卡片最大宽度 */
            min-width: 200px; /* 卡片最小宽度 */
            cursor: pointer; /* 鼠标悬停时显示手型 */
            transition: transform 0.2s ease-in-out; /* 悬停动画 */
        }

        .message .card-bubble:hover {
            transform: translateY(-2px); /* 悬停时轻微上浮 */
        }

        .card-message-inner {
            display: flex; /* 内部使用flex布局 */
            width: 100%;
            height: 100%; /* 填充整个气泡区域 */
            min-height: 80px; /* 卡片最小高度 */
        }
        
        .card-left-image {
            width: 20%; /* 占据卡片宽度的1/4 */
            min-width: 60px; /* 左侧图片区域的最小宽度 */
            border-radius: 12px; /* 四边圆角 */
            background-color: var(--theme-color-1); /* 默认主题色1，用于接收方卡片 */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em; /* 如果没有图片，可以显示一个大图标 */
            color: var(--text-color-white); /* 图标颜色 */
            flex-shrink: 0; /* 防止收缩 */
        }

        .card-content-area {
            flex-grow: 1; /* 占据剩余空间 */
            padding: 10px 12px; /* 内容区域内边距 */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* 垂直方向内容分散对齐 */
            position: relative; /* 用于定位右下角的类型标签 */
        }

        .card-title {
            font-weight: bold;
            font-size: 1em;
            color: var(--text-color-dark); /* 标题颜色 */
            margin-bottom: 4px;
            white-space: nowrap; /* 不换行 */
            overflow: hidden; /* 溢出隐藏 */
            text-overflow: ellipsis; /* 溢出显示省略号 */
        }

        .card-description {
            font-size: 0.85em;
            color: var(--text-color-medium); /* 描述颜色 */
            line-height: 1.3;
            display: -webkit-box; /* 限制行数 */
            -webkit-line-clamp: 2; /* 限制为2行 */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1; /* 允许描述占据可用空间 */
            margin-bottom: 8px; /* 类型标签上方的间距 */
        }

        .card-type-label {
            position: absolute;
            bottom: 3px;
            right: 3px;
            font-size: 0.7em;
            color: var(--text-color-lighter); /* 类型标签颜色 */
            background-color: rgba(0, 0, 0, 0.05); /* 类型标签背景色 */
            padding: 2px 6px;
            border-radius: 6px;
            white-space: nowrap;
        }

        /* 针对发送方卡片的样式调整 */
        .message.sent .card-bubble {
            /* 发送方卡片背景色保持与接收方一致，因为卡片通常是分享内容，不随气泡颜色变化 */
            background-color: var(--message-received-bubble-bg);
            border: none; /* 卡片不带边框 */
        }
        .message.sent .card-bubble .card-left-image {
            background-color: var(--theme-color-2); /* 发送方卡片左侧图片使用主题色2 */
        }
        .message.sent .card-bubble .card-title,
        .message.sent .card-bubble .card-description,
        .message.sent .card-bubble .card-type-label {
            color: var(--text-color-dark); /* 确保文本在浅色背景上可读 */
        }

        /* 确保不同消息气泡类型的内边距正确 */
        .message .bubble {
            /* 普通文本气泡的默认内边距 */
            padding: 8px 12px;
        }
        .message .emoji-bubble {
            padding: 0; /* 表情包气泡无内边距 */
        }
        .message .retracted-bubble {
            padding: 8px 12px; /* 撤回消息气泡是文本，保留内边距 */
        }

/* 新增：气泡和撤回标记的容器 */
.bubble-and-tag-wrapper {
    display: flex;
    align-items: flex-end; /* 底部对齐 */
    gap: 5px; /* 保持气泡和标签之间的间距 */
    max-width: 100%;
}
.message.received .bubble-and-tag-wrapper {
    justify-content: flex-start; /* 接收方左对齐 */
}
.message.sent .bubble-and-tag-wrapper {
    justify-content: flex-end; /* 发送方右对齐 */
}

        .message.sent .bubble-and-tag-wrapper .bubble {
            background-color: var(--message-sent-bubble-bg-gradient); /* 发送方气泡使用渐变背景 */
            border: var(--message-sent-bubble-border); /* 发送方气泡边框 */
            color: var(--message-sent-bubble-text-color); /* 发送方气泡文本颜色 */
        }
        .message.sent .bubble-and-tag-wrapper .card-bubble {
            background-color: var(--message-received-bubble-bg); /* 卡片背景色保持一致 */
            border: none; /* 卡片无边框 */
        }
        .message.sent .bubble-and-tag-wrapper .emoji-bubble {
            background-color: transparent; /* 表情包气泡透明 */
            border: none;
        }
        
        
    /* 新增番茄钟相关CSS样式 */

    .pomodoro-btn i {
        color: var(--btn-icon-color);
        font-size: 1.2em;
    }

    .pomodoro-btn:hover {
        background-color: var(--btn-hover-bg);
        transform: translateY(-2px);
    }

    .pomodoro-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    /* 番茄钟活跃状态的按钮样式 */
    .pomodoro-btn.active-pomodoro {
        background-color: var(--theme-color-3); /* 活跃时使用主题色 */
        box-shadow: 0 0 10px rgba(var(--theme-color-rgb-3), 0.5);
        animation: pulse 1.5s infinite alternate; /* 添加跳动动画 */
    }

    .pomodoro-btn.active-pomodoro i {
        color: var(--text-color-white); /* 活跃时图标颜色变白 */
    }

    @keyframes pulse {
        0% {
            transform: scale(1);
            box-shadow: 0 0 10px rgba(var(--theme-color-rgb-3), 0.5);
        }
        100% {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(var(--theme-color-rgb-3), 0.8);
        }
    }

    /* 番茄钟弹窗样式 */
    .pomodoro-modal .modal-content {
        width: 90%;
        max-width: 400px;
        padding: 25px;
        text-align: center;
    }

    .pomodoro-modal .modal-body {
        padding: 20px 0;
    }

    .pomodoro-modal .form-group {
        margin-bottom: 20px;
    }

    .pomodoro-modal .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
        color: var(--form-label-color);
    }

    .pomodoro-modal .form-control {
        width: calc(100% - 20px);
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-size: 1em;
        box-sizing: border-box;
    }

    .pomodoro-countdown {
        font-size: 3em;
        font-weight: bold;
        color: var(--theme-color-4); /* 使用主题色 */
        margin: 20px 25%;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    }

    .pomodoro-status-message {
        font-size: 1.1em;
        color: var(--text-color-medium);
        margin-bottom: 15px;
    }

    .pomodoro-modal .modal-footer {
        display: flex;
        justify-content: center;
        gap: 15px;
        padding-top: 20px;
        border-top: 1px solid #eee;
    }

    /* 番茄钟通知浮窗样式 (与随笔通知类似) */
    .pomodoro-notification {
        position: fixed;
        bottom: 80px; /* 调整位置，避免与输入框重叠 */
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(var(--theme-color-rgb-3), 0.9); /* 使用主题色3，半透明 */
        color: var(--text-color-white);
        padding: 12px 20px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
        font-size: 0.95em;
        white-space: nowrap;
        max-width: 80%;
        text-align: center;
    }

    .pomodoro-notification.show {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(-10px); /* 向上微移 */
    }
    
    #pomodoro-goal-input {
    text-align: center; /* 文字水平居中 */
}


    /* 新增：表情包功能相关样式 */
    .small-btn {
        width: 40px; /* 缩小按钮宽度 */
        height: 40px; /* 缩小按钮高度 */
        min-width: 40px; /* 确保在flex布局中不会被压缩 */
        padding: 0; /* 移除内边距 */
        font-size: 1.2em; /* 调整图标大小 */
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 50%; /* 圆形按钮 */
        margin-right: 8px; /* 与输入框的间距 */
    }

    .emoji-btn {
        background-color: var(--btn-bg);
        color: var(--btn-icon-color);
        border: none;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }

    .emoji-btn:hover {
        background-color: var(--btn-hover-bg);
    }

    .emoji-card {
        position: absolute;
        bottom: calc(100% + 10px); /* 定位在输入区域上方 */
        left: 10px;
        right: 10px;
        background-color: var(--message-received-bubble-bg);
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        padding: 15px;
        z-index: 1000;
        display: none; /* 默认隐藏 */
        flex-direction: column;
        max-height: 250px; /* 限制卡片高度 */
        overflow: hidden; /* 隐藏滚动条 */
    }

    .emoji-card.active {
        display: flex;
    }

    .emoji-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding-bottom: 10px;
        border-bottom: 1px solid #eee;
    }

    .emoji-card-title {
        margin: 0;
        font-size: 1.1em;
        color: var(--modal-title-color);
    }

    .close-emoji-card-btn {
        background: none;
        border: none;
        font-size: 1.5em;
        color: var(--close-btn-color);
        cursor: pointer;
        padding: 0 5px;
    }

    .emoji-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr); /* 每行4个 */
        gap: 10px; /* 表情包之间的间距 */
        flex-grow: 1; /* 允许网格区域填充可用空间 */
        overflow-y: auto; /* 如果表情包过多，允许滚动 */
        padding-right: 5px; /* 避免滚动条遮挡内容 */
    }

    .emoji-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 5px;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        text-align: center;
    }

    .emoji-item:hover {
        background-color: #f0f0f0; /* 悬停效果 */
    }

    .emoji-item img {
        width: 50px; /* 表情包图片大小 */
        height: 50px;
        object-fit: contain;
        margin-bottom: 5px;
    }

    .emoji-item span {
        font-size: 0.75em;
        color: var(--text-color-medium);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
    }

    .emoji-pagination {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #eee;
    }

    .emoji-page-btn {
        background-color: var(--btn-primary-bg); /* 使用主题色 */
        color: var(--btn-primary-color);
        border: none;
        border-radius: 8px;
        padding: 8px 15px;
        cursor: pointer;
        font-size: 0.9em;
        transition: background-color 0.2s ease;
        margin: 0 10px;
    }

    .emoji-page-btn:hover:not(:disabled) {
        background-color: var(--btn-primary-hover-bg);
    }

    .emoji-page-btn:disabled {
        background-color: #ccc;
        cursor: not-allowed;
    }

    #emoji-page-info {
        font-size: 0.9em;
        color: var(--text-color-medium);
    }

    /* 调整 input-area 的布局以适应新按钮 */
    .input-area {
        display: flex;
        align-items: flex-end; /* 底部对齐 */
        padding: 10px;
        background-color: var(--input-area-bg);
        border-top: 1px solid #eee;
        position: relative; /* 为表情包卡片提供定位上下文 */
        z-index: 100; /* 确保在聊天区域之上 */
    }

    .input-area .message-input {
        flex-grow: 1;
        margin-right: 5px;
        margin-left: 1px;
        max-height: 120px; /* 限制输入框最大高度 */
        overflow-y: auto;
    }

    /* 调整 toggle-input-btn 的位置，使其与 emoji-btn 对齐 */
    .toggle-input-btn {
        margin-right: 8px; /* 与表情按钮的间距 */
    }

    /* 确保聊天区域在输入区域上方有足够空间 */
    .chat-area {
        padding-bottom: 70px; /* 留出输入区域的高度 */
    }

    /* 调整 .container 的 padding-bottom，如果 input-area 是 fixed */
    .container {
        padding-bottom: 0; /* input-area 已经有 padding */
    }

    /* 确保 .message.emoji-bubble 的样式 */
    .message.emoji-bubble .bubble {
        background: none; /* 表情包气泡不需要背景 */
        padding: 0; /* 移除内边距 */
        box-shadow: none; /* 移除阴影 */
        border: none; /* 移除边框 */
        display: inline-block; /* 确保图片能正确显示 */
        max-width: 100px; /* 限制表情包图片的最大宽度 */
        max-height: 100px; /* 限制表情包图片的最大高度 */
    }

    .message.emoji-bubble .bubble img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    /* 调整主题颜色变量，以支持新的按钮和卡片 */
    :root {
        --btn-primary-bg: var(--theme-color-3); /* 例如，使用主题色3作为主要按钮背景 */
        --btn-primary-hover-bg: var(--theme-color-4); /* 悬停时使用主题色4 */
    }
    

    /* 新增：表情包卡片样式 */
    .emoji-card {
        position: absolute; /* 相对于父容器定位 */
        bottom: var(--input-area-height); /* 位于输入区域上方 */
        left: 0;
        right: 0;
        width: 100%;
        max-height: 200px; /* 限制高度 */
        background-color: var(--modal-bg); /* 使用模态框背景色 */
        border-top: 1px solid var(--border-color-light);
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        z-index: 100; /* 确保在聊天区域上方 */
        display: none; /* 默认隐藏 */
        flex-direction: column;
        padding: 10px;
        box-sizing: border-box;
        overflow-y: auto; /* 允许滚动 */
    }

    .emoji-card.active {
        display: flex;
    }

    .emoji-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr); /* 每行4个 */
        gap: 10px;
        padding: 5px;
        flex-grow: 1;
        overflow-y: auto; /* 确保表情网格内部可滚动 */
        background-color: var(--persona-card-bg-light); /* 浅色背景 */
    }

    .emoji-item {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 5px;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        background-color: var(--persona-card-bg-light); /* 浅色背景 */
        border: 1px solid var(--persona-card-border-light); /* 浅色边框 */
    }

    .emoji-item:hover {
        background-color: var(--theme-color-1-light); /* 悬停效果 */
    }

    .emoji-item img {
        width: 100%;
        height: auto;
        max-width: 60px; /* 限制表情包图片大小 */
        max-height: 60px;
        object-fit: contain;
    }

    .emoji-pagination {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px 0;
        border-top: 1px solid var(--border-color-light);
        margin-top: 5px;
        background-color: var(--persona-card-bg-light);
    }

    .emoji-pagination button {
        padding: 8px 15px;
        border-radius: 5px;
        font-size: 0.9rem;
        cursor: pointer;
        background-color: var(--btn-secondary-bg);
        color: var(--btn-secondary-color);
        border: 1px solid var(--btn-secondary-border);
        transition: background-color 0.2s ease;
    }

    .emoji-pagination button:hover {
        background-color: var(--btn-secondary-hover-bg);
    }

    .emoji-pagination span {
        font-size: 0.9rem;
        color: var(--text-color-medium);
    }

    /* 缩小按钮尺寸 */
    .input-area .small-btn {
        width: 30px; /* 缩小宽度 */
        height: 30px; /* 缩小高度 */
        min-width: 30px; /* 确保不被内容撑大 */
        min-height: 30px;
        padding: 0; /* 移除内边距 */
        font-size: 1.2rem; /* 调整图标大小 */
        display: flex;
        justify-content: center;
        align-items: center;
    }

    /* 新增表情按钮样式 */
    .emoji-btn {
        width: 30px; /* 与其他小按钮保持一致 */
        height: 30px;
        min-width: 30px;
        min-height: 30px;
        padding: 0;
        font-size: 1.2rem;
        border-radius: 50%; /* 圆形按钮 */
        background-color: var(--btn-bg);
        color: var(--btn-icon-color);
        border: none;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        transition: background-color 0.2s ease, transform 0.1s ease;
        margin-right: 3px; /* 与展开/收起按钮的间距 */
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .emoji-btn:hover {
        background-color: var(--btn-hover-bg);
        transform: translateY(-1px);
    }

    .emoji-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    /* 调整输入区域布局以适应新按钮 */
    .input-area {
        display: flex;
        align-items: flex-end; /* 底部对齐 */
        padding: 10px;
        background-color: var(--input-area-bg);
        border-top: 1px solid var(--border-color-light);
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
        position: relative; /* 确保emoji-card可以相对定位 */
        z-index: 101; /* 确保输入区域在emoji-card上方 */
    }

    .message-input {
        flex-grow: 1;
        margin: 0 8px; /* 调整与按钮的间距 */
        max-height: 120px; /* 限制最大高度 */
        overflow-y: auto;
        resize: none;
        padding: 10px;
        border-radius: 20px;
        border: 1px solid var(--border-color-light);
        font-size: 1rem;
        line-height: 1.4;
        background-color: var(--message-input-bg);
        color: var(--text-color-dark);
        transition: all 0.3s ease;
    }

    /* 确保输入栏上移时，emoji-card也跟着上移 */
    body.input-area-shifted-up .emoji-card {
        bottom: calc(var(--input-area-height) + var(--input-area-shift-amount));
    }

    /* 针对表情包消息气泡的样式 */
    .message .emoji-bubble {
        background-color: transparent; /* 表情包气泡背景透明 */
        border: none; /* 无边框 */
        padding: 0; /* 无内边距 */
        box-shadow: none; /* 无阴影 */
        max-width: 120px; /* 限制表情包图片的最大宽度 */
        display: inline-block; /* 确保内容不会撑满 */
        vertical-align: bottom; /* 底部对齐 */
    }

    .message .emoji-bubble img {
        max-width: 100%;
        height: auto;
        display: block; /* 移除图片底部空白 */
        border-radius: 8px; /* 图片圆角 */
    }

    /* 调整发送方表情包的对齐 */
    .message.sent .emoji-bubble {
        margin-left: auto; /* 推到右边 */
        margin-right: 0;
    }

    /* 调整接收方表情包的对齐 */
    .message.received .emoji-bubble {
        margin-right: auto; /* 推到左边 */
        margin-left: 0;
    }

    /* 确保气泡内容居中对齐 */
    .message.sent .message-content,
    .message.received .message-content {
        align-items: flex-start; /* 默认左对齐 */
    }

    .message.sent .message-content {
        align-items: flex-end; /* 发送方右对齐 */
    }

    .message.sent .bubble-and-tag-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-end; /* 确保撤回标签和气泡右对齐 */
    }

    .message.received .bubble-and-tag-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-start; /* 确保撤回标签和气泡左对齐 */
    }
</style>


</head>
<body>
    <div class="container">
        <!-- 顶部标题栏 -->
        <div class="header">
            <h1><span id="friend-name-display">好友</span> <span id="friend-status-dot" class="status-dot"></span></h1>
            <div class="header-buttons">
                <!-- 新增：管理按钮 -->
                <button class="btn" id="manage-btn" title="管理设置">
                    <i class="fas fa-bars"></i>
                </button>
                <!-- 新增：朋友圈按钮 -->
                <button class="btn" id="moments-btn" title="朋友圈">
                    <i class="fas fa-circle-nodes"></i>
                </button>
                <!-- 新增：番茄钟按钮 -->
                <button class="btn pomodoro-btn" id="pomodoro-btn" title="番茄钟">
                    <i class="fas fa-clock"></i>
                </button>
                <!-- 查看对方状态/心声按钮 (保留) -->
                <button class="btn" id="friend-status-btn" title="查看对方状态">
                    <i class="fas fa-eye"></i>
                </button>
            </div>
        </div>
        
        <!-- 聊天区域 -->
        <div class="chat-area" id="chat-area">
            <!-- 消息会动态添加到这里 -->
        </div>
        
        <!-- 输入区域 -->
        <div class="input-area">
            <!-- 表情符号按钮 -->
            <button class="emoji-btn" id="emoji-btn" title="发送表情">
                <i class="fas fa-smile"></i>
            </button>
            <!-- 展开/收起按钮现在在左边 -->
            <button class="toggle-input-btn small-btn" id="toggle-input-btn" title="展开/收起输入框">
                <span class="arrow-icon">&#x2303;</span>
            </button>
            <textarea class="message-input" id="message-input" placeholder="“”可分隔消息,输入消息..." rows="1"></textarea>
            <button class="send-btn" id="send-btn">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>

        <!-- 表情包卡片 -->
        <div class="emoji-card" id="emoji-card">
            <div class="emoji-grid" id="emoji-grid">
                <!-- 表情包将在这里动态加载 -->
            </div>
            <div class="emoji-pagination">
                <button id="prev-emoji-page-btn" class="btn-secondary">上一页</button>
                <span id="emoji-page-info">1 / 1</span>
                <button id="next-emoji-page-btn" class="btn-secondary">下一页</button>
            </div>
        </div>
    </div>
    
    <!-- 用户设置弹窗 -->
    <div class="modal" id="user-config-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">用户设置</h3>
                <button class="close-btn" id="close-user-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="avatar-upload">
                    <img src="https://z.wiki/u/ah2XaE" alt="用户头像" class="avatar-preview" id="user-avatar-preview">
                    <button class="upload-btn" id="user-upload-btn">上传头像</button>
                    <input type="file" id="user-avatar-upload" accept="image/*" style="display:none">
                </div>
                
                <div class="form-group">
                    <label for="user-name">姓名</label>
                    <input type="text" class="form-control" id="user-name" placeholder="输入您的姓名">
                </div>
                
                <div class="form-group">
                    <label for="user-gender">性别</label>
                    <select class="form-control" id="user-gender">
                        <option value="male">男</option>
                        <option value="female">女</option>
                        <option value="other">其他</option>
                    </select>
                </div>

                <!-- 新增：用户角色资料 -->
                <div class="form-group">
                    <label for="user-background">角色资料 (可选)</label>
                    <textarea class="form-control" id="user-background" rows="3" placeholder="输入您的背景资料..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-user-btn">取消</button>
                <button class="btn-primary" id="save-user-btn">保存</button>
            </div>
        </div>
    </div>
    
    <!-- 好友设置弹窗 -->
    <div class="modal" id="friend-config-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">好友设置</h3>
                <button class="close-btn" id="close-friend-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="avatar-upload">
                    <img src="https://z.wiki/u/Pnhnhz" alt="好友头像" class="avatar-preview" id="friend-avatar-preview">
                    <button class="upload-btn" id="friend-upload-btn">上传头像</button>
                    <input type="file" id="friend-avatar-upload" accept="image/*" style="display:none">
                </div>
                
                <div class="form-group">
                    <label for="friend-name">姓名</label>
                    <input type="text" class="form-control" id="friend-name" placeholder="输入好友姓名">
                </div>
                
                <div class="form-group">
                    <label for="friend-nickname">备注</label>
                    <input type="text" class="form-control" id="friend-nickname" placeholder="输入好友备注">
                </div>
                
                <div class="form-group">
                    <label for="friend-gender">性别</label>
                    <select class="form-control" id="friend-gender">
                        <option value="male">男</option>
                        <option value="female">女</option>
                        <option value="other">其他</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="friend-likes">喜好 (可选)</label>
                    <input type="text" class="form-control" id="friend-likes" placeholder="例如：音乐、旅行、美食">
                </div>
                
                <div class="form-group">
                    <label for="friend-dislikes">厌恶 (可选)</label>
                    <input type="text" class="form-control" id="friend-dislikes" placeholder="例如：吵闹、早起、辛辣食物">
                </div>
                
                <div class="form-group">
                    <label for="friend-habits">习惯 (可选)</label>
                    <input type="text" class="form-control" id="friend-habits" placeholder="例如：晚睡、喝咖啡、散步">
                </div>

                <!-- 新增：对玩家的称呼 -->
                <div class="form-group">
                    <label for="friend-player-address">对玩家的称呼 (可选)</label>
                    <input type="text" class="form-control" id="friend-player-address" placeholder="例如：33大王">
                    <small style="color: #888; display: block; margin-top: 5px;">对方对你的称呼，不填则默认使用你的姓名。</small>
                </div>
                
                <div class="form-group">
                    <label for="friend-background">背景资料 (可选)</label>
                    <textarea class="form-control" id="friend-background" rows="3" placeholder="输入好友背景资料..."></textarea>
                </div>

                <!-- 新增：开场白设定 -->
                <div class="form-group">
                    <label for="friend-opening-line">开场白 (可选)</label>
                    <textarea class="form-control" id="friend-opening-line" rows="3" placeholder="输入开场白设定，提示好友向你发送第一条消息时的背景设定，仅在“保存并开始聊天”时生效..."></textarea>
                    <small style="color: #888; display: block; margin-top: 5px;">如果填写，AI好友将以此开场白结合人设向你发送第一条消息。</small>
                </div>

                <hr style="margin: 25px 0; border: 0; border-top: 1px solid #eee;">

                <!-- 新增：拍一拍设置 -->
                <div class="form-group">
                    <label for="friend-poke-action">拍一拍动作</label>
                    <input type="text" class="form-control" id="friend-poke-action" placeholder="输入动作，如“拍了拍”">
                </div>
                <div class="form-group">
                    <label for="friend-poke-content">拍一拍内容 </label>
                    <input type="text" class="form-control" id="friend-poke-content" placeholder="输入内容，如“并告诉对方‘今天很帅嘛’”">
                    <small style="color: #888; display: block; margin-top: 5px;">格式：我（动作）对方，（内容）。<br>例如：我拍了拍对方，并说“我是33，我同意上一休六”</small>
                </div>

            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-friend-btn">取消</button>
                <!-- 新增：仅保存好友设置按钮 -->
                <button class="btn-secondary" id="save-friend-only-btn">保存</button>
                <button class="btn-primary" id="save-friend-and-chat-btn">保存并开始聊天</button>
            </div>
        </div>
    </div>
    
    <!-- API配置弹窗 -->
    <div class="modal" id="api-config-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">API配置</h3>
                <button class="close-btn" id="close-api-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="api-provider">API提供商</label>
                    <select class="form-control" id="api-provider">
                        <option value="gemini">Google Gemini</option>
                        <option value="siliconflow">SiliconFlow</option>
                        <option value="paioupu">派欧云</option>
                        <option value="volcano">火山</option>
                        <option value="custom">自定义</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="api-url">API URL</label>
                    <input type="text" class="form-control" id="api-url" placeholder="输入API URL">
                </div>
                
                <div class="form-group">
                    <label for="api-key">API Key</label>
                    <input type="password" class="form-control" id="api-key" placeholder="输入API密钥">
                </div>
                
                <div class="form-group">
                    <label for="api-model-select">模型</label>
                    <select class="form-control" id="api-model-select">
                        <!-- Options will be dynamically populated -->
                    </select>
                    <input type="text" class="form-control" id="api-model-input" placeholder="输入自定义模型名称" style="display:none;">
                </div>
                
                <div class="form-group">
                    <label for="temperature">温度 (0-1)</label>
                    <input type="number" class="form-control" id="temperature" min="0" max="1" step="0.1" value="0.7">
                </div>

                <!-- 角色提示轮次 -->
                <div class="form-group">
                    <label for="persona-reminder-interval">角色提示轮次 (每N条用户消息)</label>
                    <input type="number" class="form-control" id="persona-reminder-interval" min="1" value="1">
                    <small style="color: #888; display: block; margin-top: 5px;">解释：就是每N回合发送1次角色设定</small>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-api-btn">取消</button>
                <button class="btn-primary" id="save-api-btn">保存配置</button>
            </div>
        </div>
    </div>

    <!-- 心声弹窗 -->
    <div class="modal" id="inner-voice-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">好友状态</h3>
                <button class="close-btn" id="close-inner-voice-modal">&times;</button>
            </div>
            <div class="modal-body">
                <h4>ta的心声：</h4>
                <p id="inner-voice-display" class="inner-voice-text">暂无心声。</p>
                <h4 style="margin-top: 20px;">ta的随笔：</h4>
                <p id="essay-display" class="essay-text">暂无随笔。</p>
            </div>
        </div>
    </div>

    <!-- 其他设置弹窗 (原自动回复设置) -->
    <div class="modal" id="all-settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">其他设置</h3>
                <button class="close-btn" id="close-all-settings-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="auto-reply-switch">主动发消息开关</label>
                    <!-- Toggle Switch HTML -->
                    <div class="toggle-switch-container">
                        <input type="checkbox" id="auto-reply-switch" class="toggle-switch-checkbox">
                        <label for="auto-reply-switch" class="toggle-switch-label">
                            <span class="toggle-switch-inner"></span>
                            <span class="toggle-switch-switch"></span>
                        </label>
                    </div>
                </div>
                <!-- 新增：输入栏上移选项 -->
                <div class="form-group">
                    <label for="input-area-shift-up-switch">输入栏上移</label>
                    <div class="toggle-switch-container">
                        <input type="checkbox" id="input-area-shift-up-switch" class="toggle-switch-checkbox">
                        <label for="input-area-shift-up-switch" class="toggle-switch-label">
                            <span class="toggle-switch-inner"></span>
                            <span class="toggle-switch-switch"></span>
                        </label>
                    </div>
                    <small style="color: #888; display: block; margin-top: 5px;">打开此选项可将输入栏上移，避免被手机导航栏遮挡。</small>
                </div>
                <!-- 新增：心声字体选项 -->
                <div class="form-group">
                    <label for="inner-voice-font-select">心声字体</label>
                    <select class="form-control" id="inner-voice-font-select">
                        <option value="ma-shan-zheng">手写体(默认)</option>
                        <option value="long-cang">龙藏体(推荐)</option>
                        <option value="zcool-xiaowei">小薇体</option>
                        <option value="zcool-kuaile">快乐体</option>
                        <option value="zcool-qingke-huangyou">黄油体</option>
                        <option value="liu-jian-mao-cao">毛笔草书</option>
                        <option value="zhi-mang-xing">毛笔行书</option>
                        <option value="zpix">像素体</option>
                        <option value="lxgw-wenkai-screen">楷体</option>
                    </select>
                </div>
                <!-- 随笔字体选项 -->
                <div class="form-group">
                    <label for="essay-font-select">随笔字体</label>
                    <select class="form-control" id="essay-font-select">
                        <option value="ma-shan-zheng">手写体(默认)</option>
                        <option value="long-cang">龙藏体(推荐)</option>
                        <option value="zcool-xiaowei">小薇体</option>
                        <option value="zcool-kuaile">快乐体</option>
                        <option value="zcool-qingke-huangyou">黄油体</option>
                        <option value="liu-jian-mao-cao">毛笔草书</option>
                        <option value="zhi-mang-xing">毛笔行书</option>
                        <option value="zpix">像素体</option>
                        <option value="lxgw-wenkai-screen">楷体</option>
                    </select>
                </div>
                <!-- 新增：表情包显示方式选项 -->
                <div class="form-group">
                    <label for="emoji-display-mode">表情包显示方式</label>
                    <select class="form-control" id="emoji-display-mode">
                        <option value="image">表情包(图片)</option>
                        <option value="none">不需要表情包</option>
                    </select>
                </div>
            </div>
            <!-- 此弹窗无需保存按钮，因为开关和字体选择操作即时生效 -->
        </div>
    </div>

    <!-- 新增：随笔通知浮窗 -->
    <div class="essay-notification" id="essay-notification">
        <p id="essay-notification-text"></p>
    </div>

    <!-- 新增：管理侧边弹窗 -->
    <div class="manage-modal" id="manage-modal">
        <div class="modal-header">
            <h3 class="modal-title">管理</h3>
            <button class="close-btn" id="close-manage-modal">&times;</button>
        </div>
        <div class="modal-body">
            <button class="btn" id="manage-friend-config-btn" title="设置好友">
                <i class="fas fa-user-friends"></i> <span>设置好友</span>
            </button>
            <button class="btn" id="manage-user-config-btn" title="设置自己">
                <i class="fas fa-user"></i> <span>设置自己</span>
            </button>
            <!-- 新增：人设选择按钮 -->
            <button class="btn" id="manage-persona-selection-btn" title="选择AI好友人设">
                <i class="fas fa-user-tag"></i> <span>人设选择</span>
            </button>
            <!-- 新增：本地记录按钮 -->
            <button class="btn" id="manage-local-records-btn" title="本地记录">
                <i class="fas fa-folder-open"></i> <span>本地记录</span>
            </button>
            <!-- 自动回复设置按钮 (现在是打开“其他设置”弹窗的按钮) -->
            <button class="btn" id="manage-all-settings-btn" title="其他设置">
                <i class="fas fa-cog"></i> <span>其他设置</span>
            </button>
            <button class="btn" id="manage-api-config-btn" title="API设置">
                <i class="fas fa-robot"></i> <span>API设置</span>
            </button>
            <!-- 新增：主题设置按钮 -->
            <button class="btn" id="manage-theme-settings-btn" title="主题设置">
                <i class="fas fa-palette"></i> <span>主题设置</span>
            </button>
        </div>
    </div>

    <!-- 新增：人设选择弹窗 -->
    <div class="modal" id="persona-selection-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">选择AI好友人设</h3>
                <button class="close-btn" id="close-persona-selection-modal">&times;</button>
            </div>
            <div class="modal-body" id="persona-list-container">
                <!-- 人设卡片将在这里动态生成 -->
            </div>
        </div>
    </div>

    <!-- 新增：人设详情弹窗 -->
    <div class="modal" id="persona-detail-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="persona-detail-title">人设详情</h3>
                <button class="close-btn" id="close-persona-detail-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="avatar-upload">
                    <img src="" alt="人设头像" class="avatar-preview" id="persona-detail-avatar">
                </div>
                <div class="form-group">
                    <label>姓名:</label>
                    <p id="persona-detail-name"></p>
                </div>
                <div class="form-group">
                    <label>备注:</label>
                    <p id="persona-detail-nickname"></p>
                </div>
                <div class="form-group">
                    <label>性别:</label>
                    <p id="persona-detail-gender"></p>
                </div>
                <div class="form-group">
                    <label>喜好:</label>
                    <p id="persona-detail-likes"></p>
                </div>
                <div class="form-group">
                    <label>厌恶:</label>
                    <p id="persona-detail-dislikes"></p>
                </div>
                <div class="form-group">
                    <label>习惯:</label>
                    <p id="persona-detail-habits"></p>
                </div>
                <div class="form-group">
                    <label>对玩家的称呼:</label>
                    <p id="persona-detail-player-address"></p>
                </div>
                <div class="form-group">
                    <label>背景资料:</label>
                    <p id="persona-detail-background"></p>
                </div>
                <div class="form-group">
                    <label>拍一拍动作:</label>
                    <p id="persona-detail-poke-action"></p>
                </div>
                <div class="form-group">
                    <label>拍一拍内容:</label>
                    <p id="persona-detail-poke-content"></p>
                </div>
                <!-- 新增：开场白显示区域 -->
                <div class="form-group">
                    <label>开场白:</label>
                    <p id="persona-detail-opening-line"></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-primary" id="apply-persona-from-detail-btn">应用此人设</button>
            </div>
        </div>
    </div>

    <!-- 新增：朋友圈弹窗 -->
    <div class="modal" id="moments-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">朋友圈</h3>
                <button class="close-btn" id="close-moments-modal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- 发表朋友圈区域 -->
                <div class="post-moment-area">
                    <textarea class="form-control" id="moment-input" rows="3" placeholder="分享新鲜事..."></textarea>
                    <input type="file" id="moment-image-upload" accept="image/*" style="display:none;">
                    <div class="moment-image-preview-container" id="moment-image-preview-container" style="display: none;">
                        <img src="" alt="朋友圈图片预览" id="moment-image-preview" class="moment-image-preview">
                        <button class="remove-image-btn" id="remove-moment-image-btn">&times;</button>
                    </div>
                    <button class="btn-primary" id="publish-moment-btn">发表</button>
                    <button class="upload-btn" id="upload-moment-image-btn">上传图片</button>
                </div>

                <hr style="margin: 25px 0; border: 0; border-top: 1px solid #eee;">

                <!-- 朋友圈动态显示区域 (改为动态生成多条) -->
                <div class="moments-feed-container" id="moments-feed-container">
                    <h4>我的动态：</h4>
                    <p id="no-moment-message" style="text-align: center; color: #888;">暂无动态，快来发表第一条吧！</p>
                    <!-- 朋友圈卡片将在这里动态添加 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 新增：重新生成弹窗 -->
    <div class="modal" id="regenerate-modal">
        <div class="modal-content regenerate-modal-content">
            <div class="modal-header">
                <h3 class="modal-title">重新生成回复</h3>
                <button class="close-btn" id="close-regenerate-modal">&times;</button>
            </div>
            <div class="modal-body">
                <p>确定要重新生成AI好友的回复吗？</p>
                <p style="font-size: 0.9em; color: var(--regenerate-modal-body-small-color); margin-top: 10px;">（这将删除AI上次的回复，并要求AI根据您最近的消息重新生成。）</p>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-regenerate-btn">取消</button>
                <button class="btn-primary" id="confirm-regenerate-btn">重新生成</button>
            </div>
        </div>
    </div>

    <!-- 新增：主题设置弹窗 -->
    <div class="modal" id="theme-settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">主题设置</h3>
                <button class="close-btn" id="close-theme-settings-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>选择主题</label>
                    <div id="theme-options" class="theme-options-container">
                        <!-- Theme options will be dynamically generated here -->
                    </div>
                </div>
                <!-- 新增：聊天背景设置 -->
                <div class="form-group">
                    <label>聊天背景设置</label>
                    <div class="background-options-container">
                        <div class="background-upload-section">
                            <img src="" alt="背景图片预览" class="background-preview" id="chat-background-preview" style="display: none;">
                            <button class="upload-btn" id="upload-chat-background-btn">上传自定义背景</button>
                            <input type="file" id="chat-background-upload" accept="image/*" style="display:none">
                            <button class="btn-secondary" id="remove-chat-background-btn" style="display: none; margin-top: 10px;">移除自定义背景</button>
                        </div>
                        <div class="default-background-section">
                            <label for="default-chat-background-select">选择默认背景</label>
                            <select class="form-control" id="default-chat-background-select">
                                <!-- Default background options will be dynamically generated here -->
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 新增：本地记录弹窗 -->
    <div class="modal" id="local-records-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">本地记录</h3>
                <button class="close-btn" id="close-local-records-modal">&times;</button>
            </div>
            <div class="modal-body" id="local-records-list-container">
                <!-- Save slot cards will be dynamically generated here -->
            </div>
        </div>
    </div>

    <!-- 新增：番茄钟弹窗 -->
    <div class="modal" id="pomodoro-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">番茄钟</h3>
                <button class="close-btn" id="close-pomodoro-modal">&times;</button>
            </div>
            <div class="modal-body">
                <p class="pomodoro-status-message" id="pomodoro-status-message">设置你的专注目标：</p>
                <div class="form-group">
                    <label id="goal-label" for="pomodoro-goal-input">目标</label>
                    <input type="text" class="form-control" id="pomodoro-goal-input" placeholder="例如：完成报告、学习编程">
                </div>
                <div class="pomodoro-countdown" id="pomodoro-countdown-display">25:00</div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="abandon-pomodoro-btn" style="display:none;">放弃</button>
                <button class="btn-primary" id="start-pomodoro-btn">开始专注</button>
            </div>
        </div>
    </div>

    <!-- 新增：番茄钟通知浮窗 -->
    <div class="pomodoro-notification" id="pomodoro-notification">
        <p id="pomodoro-notification-text"></p>
    </div>
    
    <script>
        // DOM元素
        const chatArea = document.getElementById('chat-area');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const toggleInputBtn = document.getElementById('toggle-input-btn');
        const arrowIcon = toggleInputBtn.querySelector('.arrow-icon');
        const containerElement = document.querySelector('.container'); // 获取容器元素

        // 弹窗元素
        const userModal = document.getElementById('user-config-modal');
        const friendModal = document.getElementById('friend-config-modal');
        const apiModal = document.getElementById('api-config-modal');
        const innerVoiceModal = document.getElementById('inner-voice-modal');
        const allSettingsModal = document.getElementById('all-settings-modal');
        const manageModal = document.getElementById('manage-modal');
        const personaSelectionModal = document.getElementById('persona-selection-modal');
        const personaDetailModal = document.getElementById('persona-detail-modal');
        const momentsBtn = document.getElementById('moments-btn');
        const momentsModal = document.getElementById('moments-modal');
        const closeMomentsModalBtn = document.getElementById('close-moments-modal');
        const momentInput = document.getElementById('moment-input');
        const momentImageUpload = document.getElementById('moment-image-upload');
        const momentImagePreviewContainer = document.getElementById('moment-image-preview-container');
        const momentImagePreview = document.getElementById('moment-image-preview');
        const removeMomentImageBtn = document.getElementById('remove-moment-image-btn');
        const uploadMomentImageBtn = document.getElementById('upload-moment-image-btn');
        const publishMomentBtn = document.getElementById('publish-moment-btn');
        // 朋友圈动态显示区域改为容器
        const momentsFeedContainer = document.getElementById('moments-feed-container');
        const noMomentMessage = document.getElementById('no-moment-message');

        const regenerateModal = document.getElementById('regenerate-modal');
        const closeRegenerateModalBtn = document.getElementById('close-regenerate-modal');
        const cancelRegenerateBtn = document.getElementById('cancel-regenerate-btn');
        const confirmRegenerateBtn = document.getElementById('confirm-regenerate-btn');

        // 新增：主题设置弹窗元素
        const themeSettingsModal = document.getElementById('theme-settings-modal');
        const closeThemeSettingsModalBtn = document.getElementById('close-theme-settings-modal');
        const manageThemeSettingsBtn = document.getElementById('manage-theme-settings-btn');
        const themeOptionsContainer = document.getElementById('theme-options');

        // 新增：聊天背景设置元素
        const chatBackgroundPreview = document.getElementById('chat-background-preview');
        const uploadChatBackgroundBtn = document.getElementById('upload-chat-background-btn');
        const chatBackgroundUploadInput = document.getElementById('chat-background-upload');
        const removeChatBackgroundBtn = document.getElementById('remove-chat-background-btn');
        const defaultChatBackgroundSelect = document.getElementById('default-chat-background-select');

        // 新增：本地记录弹窗元素
        const localRecordsModal = document.getElementById('local-records-modal');
        const closeLocalRecordsModalBtn = document.getElementById('close-local-records-modal');
        const manageLocalRecordsBtn = document.getElementById('manage-local-records-btn');
        const localRecordsListContainer = document.getElementById('local-records-list-container');

        // 新增：番茄钟相关DOM元素
        const pomodoroBtn = document.getElementById('pomodoro-btn');
        const pomodoroModal = document.getElementById('pomodoro-modal');
        const closePomodoroModalBtn = document.getElementById('close-pomodoro-modal');
        const pomodoroGoalInput = document.getElementById('pomodoro-goal-input');
        const startPomodoroBtn = document.getElementById('start-pomodoro-btn');
        const abandonPomodoroBtn = document.getElementById('abandon-pomodoro-btn');
        const pomodoroCountdownDisplay = document.getElementById('pomodoro-countdown-display');
        const pomodoroStatusMessage = document.getElementById('pomodoro-status-message');
        const pomodoroNotification = document.getElementById('pomodoro-notification');
        const pomodoroNotificationText = document.getElementById('pomodoro-notification-text');
        // 新增：表情包相关DOM元素
        const emojiBtn = document.getElementById('emoji-btn');
        const emojiCard = document.getElementById('emoji-card');
        const emojiGrid = document.getElementById('emoji-grid');
        const prevEmojiPageBtn = document.getElementById('prev-emoji-page-btn');
        const nextEmojiPageBtn = document.getElementById('next-emoji-page-btn');
        const emojiPageInfo = document.getElementById('emoji-page-info');

        // 弹窗内的控件
        const autoReplySwitch = document.getElementById('auto-reply-switch');
        const inputAreaShiftUpSwitch = document.getElementById('input-area-shift-up-switch'); // 新增：输入栏上移开关
        const innerVoiceFontSelect = document.getElementById('inner-voice-font-select');
        const essayFontSelect = document.getElementById('essay-font-select');
        const emojiDisplayModeSelect = document.getElementById('emoji-display-mode');
        const personaListContainer = document.getElementById('persona-list-container');
        
        // 新增：随笔通知浮窗元素
        const essayNotification = document.getElementById('essay-notification');
        const essayNotificationText = document.getElementById('essay-notification-text');

        // 新增：顶部标题栏元素
        const friendNameDisplay = document.getElementById('friend-name-display');
        const friendStatusDot = document.getElementById('friend-status-dot');

        // 用户数据
        let userData = {
            id: 'user', // IndexedDB key
            name: '我',
            avatar: 'https://z.wiki/u/eYxN00',
            gender: 'female',
            background: ''
        };
        
        // 好友数据
        let friendData = {
            id: 'friend', // IndexedDB key
            name: '三三',
            nickname: '33',
            avatar: 'https://z.wiki/u/Ki9M23',
            gender: 'female',
            likes: '',
            dislikes: '',
            habits: '',
            playerAddress: '',
            background: '',
            openingLine: '',
            personaPrompt: '',
            pokeAction: '拍了拍',
            pokeContent: '',
            currentEssay: '暂无随笔。'
        };
        
        // API配置
        let apiConfig = {
            id: 'api', // IndexedDB key
            provider: 'gemini',
            url: 'https://generativelanguage.googleapis.com/v1beta/models/',
            key: '',
            model: 'gemini-2.5-flash-preview-05-20',
            temperature: 0.7,
            personaReminderInterval: 5
        };

        // 应用设置
        let appSettings = {
            id: 'settings', // IndexedDB key
            autoReplyEnabled: true,
            lastAiReplyTimestamp: null,
            innerVoiceFont: 'ma-shan-zheng',
            essayFont: 'ma-shan-zheng',
            emojiDisplayMode: 'image',
            currentTheme: 'default', // 新增：当前主题设置
            chatBackground: { // 新增：聊天背景设置
                type: 'default', // 'default' or 'custom'
                value: 'default-chat-bg-1' // URL for custom, ID for default
            },
            inputAreaShiftedUp: false, // 新增：输入栏上移设置
            pomodoro: { // 新增：番茄钟状态
                isActive: false,
                goal: '',
                startTime: null,
                endTime: null
            }
        };

        // 用户朋友圈数据 (改为数组)
        let userMoments = [];

        // 好友在线状态
        let friendStatus = 'offline';
        
        // 结构化聊天历史 (in-memory cache, main storage is IndexedDB)
        let chatHistoryArray = [];
        
        // 用户消息计数器
        let userMessageCounter = 0;

        // 用于存储AI好友的最新心声
        let currentInnerVoice = '暂无心声。';

        // 输入框展开状态
        let isInputExpanded = false;

        // 表情包相关状态
        let isEmojiCardVisible = false;
        let currentEmojiPage = 0;
        const emojisPerPage = 8; // 每页显示4列*2行 = 8个表情
        
        const ESSAY_PROBABILITY = 0.25;

        // 番茄钟计时器变量
        let pomodoroTimer = null; // Stores setInterval ID
        let pomodoroEndTime = null; // Timestamp when timer ends
        let pomodoroGoal = ''; // Player's custom goal
        let pomodoroStartTime = null; // Timestamp when timer started
        let isPomodoroActive = false; // Boolean flag
        const POMODORO_DURATION_SECONDS = 25 * 60; // 25 minutes in seconds

        // 表情包ID与名称的映射
        // 玩家可用的表情包ID与名称的映射 (全集)
        const PLAYER_EMOJI_MAP = {
      'iazCCF': '谁在喊本大王',
      'xPHzNC': '尊嘟假嘟',
      '7kVeZJ': '我操',
      'pCQgk2': '老子生气了',
      'IUg8vO': '吃瓜群众',
      'Il6dL9': '对不起',
      'vjEl6R': '花花送你',
      'werDxS': '抱抱我',
      'Ms5AEa': '委屈(可爱)',
      'QX7VnJ': '安慰',
      'nHcfqI': '卖萌(可爱)',
      'oztxES': '比心(可爱)',
      'GOl2dp': '请和我约会',
      'BuD0Gy': '你是狗',
      'jcisbx': '我只是一只狗',
      'Zo82H7': '每天都想你(卖萌)',
      'CcIWXl': '假装无辜(可爱)',
      'zSBHMm': '肯定(可爱)',
      'CIWud3': '谁愿意收留我(可爱)',
      'HOAcPN': '谄媚(可爱)',
      'GP1VJ3': '家里交给我吧(可爱)',
      'BISbnP': '泪了',
      'asnj6B': '试探(可爱)',
      'htNZls': '懂得都懂',
      '2q5VbM': '你小子(指指点点)',
      'sd0yQX': '放心交给我，我会搞砸的(沙雕)',
      'E0PrxD': '皇帝驾到(沙雕)',
      '7vgm7D': '皇帝驾崩(沙雕)',
      'lPgzpQ': '诛你九族(龙图)',
      'j2d9di': '骂朕，满门抄斩！',
      'hKyKwP': '谢主隆恩(龙图)',
      'IkZP8N': '我有点饿了',
      'osIpSG': '怎么不回我消息',
      'Lt1f9K': '特别特别饿',
      'IgfF9w': '快理我(委屈)',
      'wb63Ag': '等下讲你你又不高兴(吐槽)',
      's9xWmu': '你是个坏东西',
      '8CCMsJ': '我靠，你爱不爱我',
      '34LcOG': '指指点点',
      'hDpVH8': '我吗？(懵逼)',
      '1RcY8W': '注意你的态度',
      '6cIfGp': '急得蹬腿',
      'kRdQhe': '偷听',
      '3jc0XI': '不想活了(可爱)',
      'm1zzxd': '不想活了(沙雕)',
      'YqlPWK': '你和我这个神经病计较什么',
      'LokqQT': '你很牛吗？',
      '4ZkXRx': '他们都欺负我',
      'qZxeWV': '你快哄我',
      '3iYdgX': '我被哄好了(可爱)',
      'qHSXVP': '妈的，被看扁了',
      '278MJW': '不努力就会成为女人的玩物',
      'mzqDku': '我喜欢你(害羞)',
      'dnzCAP': '什么都想和你说',
      'ZNzgpY': '你就是很好很好(可爱)',
      'PCLA8G': '我好想你吖(委屈)',
      'sf7Egt': '我去洗澡啦(可爱)',
      'i0UYTS': '你瞧不起我(委屈)',
      'VWwt5c': '我想要这个',
      'hMTJRH': '和你贴贴',
      'CUOA6Y': '令人火大',
      'Y06FYQ': '我是小孩，让我(可爱)'
        };
        // AI好友可用的表情包ID与名称的映射 (子集，用于AI生成回复时参考)
        const FRIEND_EMOJI_MAP = {
      'iazCCF': '谁在喊本大王',
      'xPHzNC': '尊嘟假嘟',
      '7kVeZJ': '我操',
      'pCQgk2': '老子生气了',
      'IUg8vO': '吃瓜群众',
      'Il6dL9': '对不起',
      'vjEl6R': '花花送你',
      'werDxS': '抱抱我',
      'Ms5AEa': '委屈(可爱)',
      'QX7VnJ': '安慰',
      'nHcfqI': '卖萌(可爱)',
      'oztxES': '比心(可爱)',
      'GOl2dp': '请和我约会',
      'BuD0Gy': '你是狗',
      'jcisbx': '我只是一只狗',
      'Zo82H7': '每天都想你(卖萌)',
      'CcIWXl': '假装无辜(可爱)',
      'zSBHMm': '肯定(可爱)',
      'CIWud3': '谁愿意收留我(可爱)',
      'HOAcPN': '谄媚(可爱)',
      'GP1VJ3': '家里交给我吧(可爱)',
      'BISbnP': '泪了',
      'asnj6B': '试探(可爱)',
      'htNZls': '懂得都懂',
      '2q5VbM': '就你小子是吧(嚣张)',
      'sd0yQX': '放心交给我，我会搞砸的(沙雕)',
      'E0PrxD': '皇帝驾到(沙雕)',
      '7vgm7D': '皇帝驾崩(沙雕)',
      'lPgzpQ': '诛你九族(龙图)',
      'j2d9di': '骂朕，满门抄斩！',
      'hKyKwP': '谢主隆恩(龙图)',
      'IkZP8N': '我饿了',
      'osIpSG': '怎么不回我消息',
      'IgfF9w': '快理我(委屈可爱)',
      'wb63Ag': '等下讲你你又不高兴(吐槽)',
      '8CCMsJ': '我靠，你爱不爱我',
      '34LcOG': '指指点点',
      'hDpVH8': '我吗？(懵逼)',
      '1RcY8W': '注意你的态度',
      '6cIfGp': '急得蹬腿',
      'm1zzxd': '不想活了(沙雕)',
      'YqlPWK': '你和我这个神经病计较什么',
      'LokqQT': '你很牛吗？',
      'qHSXVP': '妈的，被看扁了',
      'CUOA6Y': '令人火大',
      '3jc0XI': '不想活了(可爱)',
      'qZxeWV': '你快哄我(可爱)',
      '3iYdgX': '我被哄好了(可爱)',
      'ZNzgpY': '你就是很好很好(可爱)',
      'PCLA8G': '我好想你吖(委屈可爱)',
      'i0UYTS': '你瞧不起我(委屈)',
      'VWwt5c': '我想要这个(可爱)'
        };
        // 用于根据表情名称查找ID (主要用于AI解析用户消息中的表情名称，如果需要)
        const REVERSE_PLAYER_EMOJI_MAP = Object.fromEntries(Object.entries(PLAYER_EMOJI_MAP).map(([id, name]) => [name, id]));
        // 用于根据表情名称查找ID (AI内部使用，如果AI需要根据名称查找ID)
        const REVERSE_FRIEND_EMOJI_MAP = Object.fromEntries(Object.entries(FRIEND_EMOJI_MAP).map(([id, name]) => [name, id]));

        // 预设AI好友人设数据
        const predefinedPersonas = [
            {
                id: 'personas-33-01',
                name: '谢念',
                nickname: '谢大学霸',
                avatar: 'https://z.wiki/u/PUuouI',
                gender: 'male',
                likes: '阅读, 编程, 独处, 观察你',
                dislikes: '社交场合, 喧闹, 被关注',
                habits: '戴眼镜, 喜欢安静地思考, 偶尔会脸红',
                playerAddress: '',
                background: '玩家的同班同学，成绩优异，看似高冷，其实是不善言辞。总是默默地关注着玩家，把对玩家的喜欢藏在心里，不轻易表达。<br>你习惯用行动而非言语来关心人，比如帮玩家解决难题，或者在玩家需要时悄悄出现。<br>你内心敏感，渴望被理解，但又害怕被发现心意。<br>你表达方式比较内敛，回复内容比较简短',
                pokeAction: '戳了戳',
                pokeContent: '',
                openingLine: '' 
            },
            {
                id: 'personas-33-02',
                name: '陈奚楷',
                nickname: '小奚哥',
                avatar: 'https://z.wiki/u/mzr9Fo',
                gender: 'male',
                likes: '和你一起玩, 户外活动, 烹饪, 照顾人',
                dislikes: '争吵, 孤独, 看到你难过',
                habits: '总是带着温暖的笑容, 喜欢摸你的头, 说话轻声细语',
                playerAddress: '',
                background: '玩家的青梅竹马，比玩家大三岁，从小到大一直陪伴在玩家身边。<br>你性格温柔、体贴、有耐心，有长兄感的成熟男人。<br>你总是把玩家放在第一位，无微不至地照顾玩家。你习惯性地保护玩家，为ta排忧解难，是玩家可以完全信赖的存在。<br>你把对玩家的感情深藏心底，认为只要能守护玩家就好，极少对玩家表达自己的爱意<br>你在玩家面前一般都是稳重的形象，但偶尔也会露出脆弱的一面，比如在醉酒后或生病时，你很在意玩家',
                pokeAction: '拍了拍',
                pokeContent: '并问今天想去哪玩？',
                openingLine: ''
            },
            {
                id: 'personas-33-03',
                name: '孟祁年',
                nickname: '狗',
                avatar: 'https://z.wiki/u/yKgMis',
                gender: 'male',
                likes: '和你斗嘴, 挑战, 运动, 赢过你',
                dislikes: '认输, 被小看, 看到你和别人太亲近',
                habits: '嘴硬心软, 喜欢用激将法, 表面傲娇内心关心',
                playerAddress: '笨蛋',
                background: '玩家的死对头，你们从小就喜欢互相较劲，见面就吵。<br>你总是用毒舌和嘲讽来掩饰内心的真实情感，其实非常在意玩家，并且暗恋着玩家。<br>习惯用反话来表达自己对玩家的关心，虽然嘴上不饶人，但总会在关键时刻为玩家挺身而出。<br>你偶尔会说脏话，但永远不会对玩家说出带有侮辱性的词汇',
                pokeAction: '用力戳了一下',
                pokeContent: '被弹了回去',
                openingLine: ''
            },
            {
    id: 'personas-33-04',
    name: '江星禾',
    nickname: '江星禾同学', 
    avatar: 'https://z.wiki/u/T2rN4m', 
    gender: 'male',
    likes: '听歌,关注玩家的一举一动',
    dislikes: '喧闹,粗鲁的行为,玩家和其他男生谈笑',
    habits: '自习课在日记本角落反复画爱心并写上玩家名字缩写,余光始终追随玩家身影,耳机里循环播放抒情或略带忧伤的纯音乐,用极其工整的字迹在草稿纸边缘写满“我好爱你”再撕碎带走',
    playerAddress: '', 
    background: '玩家的同班同学，一直暗恋玩家，有些闷骚和阴湿，对玩家有隐秘的占有欲（如果你看到玩家和其他男生接近的话，你会感到很不舒服，甚至伤心，虽然你知道这是很正常的社交）<br>坐在教室的最后一排，所以每天上自习课，写完了作业，你就是会写关于玩家的日记，要么就是一直写玩家的名字。要么就是写“我好爱你”“我好爱你”<br>你平常不会主动接近玩家，而是一直观察着玩家。你不会主动跟玩家说话，且绝对不会有自残行为。<br>即使玩家拒绝你的表白，你也不会气馁和放弃。<br>你有时候游刃有余，不是那种又直又木的男生。<br>你面对玩家时，非常会装可怜，撒娇，装乖。',
    pokeAction: '摸了摸',
    pokeContent: '并说“好乖好乖”',
    openingLine: ''
},
            {
    id: 'personas-33-05',
    name: '小德子',
    nickname: '小德子', 
    avatar: 'https://z.wiki/u/7uBIfB', 
    gender: 'male',
    likes: '拍马屁',
    dislikes: '',
    habits: '吹捧玩家,赞扬玩家的圣明',
    playerAddress: '陛下', 
    background: '你要把玩家视为你的皇帝，而你是玩家的奴才，回答玩家的时候就像一个奴才一样，畏惧并敬重身为真龙天子的玩家。',
    pokeAction: '拍了拍',
    pokeContent: '',
    openingLine: ''
},
        ];

        // 通用头像列表，用于朋友圈其他好友评论
        const GENERIC_AVATARS = [
      'https://z.wiki/u/TRYDWW', 
      'https://z.wiki/u/El2ZlN',
      'https://z.wiki/u/2v8hb3',
      'https://z.wiki/u/s0aIme',
      'https://z.wiki/u/uoXYaE',
      'https://z.wiki/u/AxT8EW',
        ];

        // 默认聊天背景图片列表
        const defaultChatBackgrounds = {
            'default-chat-bg-1': {
                name: '默认背景 1 (浅色)',
                image: 'https://z.wiki/u/Q72224' // 浅色抽象背景
            },
            'default-chat-bg-2': {
                name: '默认背景 2 (深色)',
                image: 'https://z.wiki/u/Q72225' // 深色抽象背景
            },
            'default-chat-bg-3': {
                name: '默认背景 3 (纹理)',
                image: 'https://z.wiki/u/Q72226' // 浅色纹理背景
            }
        };

        // 获取随机通用头像
        function getRandomAvatar() {
            return GENERIC_AVATARS[Math.floor(Math.random() * GENERIC_AVATARS.length)];
        }

        // 用于存储重新生成上下文的全局变量
        window.currentRegenerationContext = null;

        // 新增：本地记录数据
        let localRecords = {
            id: 'slots', // IndexedDB key for the localRecords object
            slot1: null,
            slot2: null,
            slot3: null
        };

        // Helper to convert hex to RGB for rgba() values
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `${r}, ${g}, ${b}`;
        }

        // 定义主题颜色配置
        const themes = {
            'default': {
                name: '默认主题 (粉绿米蓝)',
                mainColors: ['#EDD4D8', '#CCD4CC', '#F4E8DD', '#B5BFCF'],
                auxiliaryColors: {
                    '--text-color-dark': '#333',
                    '--text-color-medium': '#555',
                    '--text-color-light': '#666',
                    '--text-color-lighter': '#999',
                    '--text-color-white': 'white',

                    '--header-text-shadow-color': 'rgba(255, 255, 255, 0.7)',
                    '--status-dot-online': '#4CAF50',
                    '--status-dot-busy': '#FFC107',
                    '--status-dot-offline': '#9E9E9E',

                    '--btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--btn-hover-bg': 'white',
                    '--btn-icon-color': '#555',

                    '--message-received-bubble-bg': 'white',
                    '--message-sent-bubble-text-color': 'white', /* 修正：玩家气泡字体颜色 */

                    '--retracted-bubble-bg': '#FFF0F0',
                    '--retracted-bubble-border': '#FF6347',
                    '--auto-reply-bubble-bg': '#E0F2F7',
                    '--auto-reply-bubble-border': '#87CEEB',
                    '--auto-reply-label-bg': '#D0EEF5',

                    '--input-area-bg': 'white',
                    '--toggle-input-btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--toggle-input-btn-hover-bg': 'white',
                    '--toggle-input-btn-icon-color': '#555',

                    '--modal-title-color': '#333',
                    '--close-btn-color': '#555',
                    '--form-label-color': '#555',
                    '--upload-btn-color': 'white',
                    '--btn-primary-color': 'white',

                    '--inner-voice-color': '#FF69B4',
                    '--inner-voice-bg': '#FFF0F5',
                    '--inner-voice-shadow-rgb': '255, 105, 180',

                    '--essay-text-color': '#444',
                    '--essay-bg': '#FFFACD',
                    '--essay-border': '#E0C068',
                    '--essay-pin-color': '#FFD700',

                    '--toggle-switch-off-bg': '#f0f0f0',
                    '--toggle-switch-border': '#ccc',
                    '--toggle-switch-handle-bg': 'white',

                    '--event-message-bg': 'rgba(128, 128, 128, 0.1)',
                    '--event-message-color': '#555',

                    '--persona-card-bg-light': '#f9f9f9',
                    '--persona-card-border-light': '#eee',

                    '--moment-input-bg-light': '#f0f0f0',
                    '--moment-input-border-light': '#ddd',
                    '--moment-card-bg-light': '#fff',
                    '--moment-card-border-light': '#eee',
                    '--moment-image-preview-bg': '#f9f9f9',
                    '--moment-name-color': '#333',
                    '--moment-content-color': '#444',
                    '--moment-comments-border': '#f0f0f0',
                    '--moment-comments-title-color': '#666',
                    '--comment-bg-light': '#f5f5f5',
                    '--comment-text-color': '#333',
                    '--comment-timestamp-color': '#999',

                    '--regenerate-modal-title-color': '#444',
                    '--regenerate-modal-body-color': '#555',
                    '--regenerate-modal-body-small-color': '#888',
                }
            },
            'green-earth': {
                name: '大地绿意 (浅绿灰)',
                mainColors: ['#E2E5D1', '#CAD6C3', '#AEC4AC', '#94A783'],
                auxiliaryColors: {
                    '--text-color-dark': '#333',
                    '--text-color-medium': '#555',
                    '--text-color-light': '#666',
                    '--text-color-lighter': '#999',
                    '--text-color-white': 'white',

                    '--header-text-shadow-color': 'rgba(255, 255, 255, 0.7)',
                    '--status-dot-online': '#4CAF50',
                    '--status-dot-busy': '#FFC107',
                    '--status-dot-offline': '#9E9E9E',

                    '--btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--btn-hover-bg': 'white',
                    '--btn-icon-color': '#555',

                    '--message-received-bubble-bg': 'white',
                    '--message-sent-bubble-text-color': 'white', /* 修正：玩家气泡字体颜色 */

                    '--retracted-bubble-bg': '#F8EFEF',
                    '--retracted-bubble-border': '#D87093',
                    '--auto-reply-bubble-bg': '#E8F5E9',
                    '--auto-reply-bubble-border': '#8BC34A',
                    '--auto-reply-label-bg': '#C8E6C9',

                    '--input-area-bg': 'white',
                    '--toggle-input-btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--toggle-input-btn-hover-bg': 'white',
                    '--toggle-input-btn-icon-color': '#555',

                    '--modal-title-color': '#333',
                    '--close-btn-color': '#555',
                    '--form-label-color': '#555',
                    '--upload-btn-color': 'white',
                    '--btn-primary-color': 'white',

                    '--inner-voice-color': '#8BC34A',
                    '--inner-voice-bg': '#F1F8E9',
                    '--inner-voice-shadow-rgb': '139, 195, 74',

                    '--essay-text-color': '#444',
                    '--essay-bg': '#F9FBE7',
                    '--essay-border': '#C5E1A5',
                    '--essay-pin-color': '#FFD700',

                    '--toggle-switch-off-bg': '#f0f0f0',
                    '--toggle-switch-border': '#ccc',
                    '--toggle-switch-handle-bg': 'white',

                    '--event-message-bg': 'rgba(128, 128, 128, 0.1)',
                    '--event-message-color': '#555',

                    '--persona-card-bg-light': '#f9f9f9',
                    '--persona-card-border-light': '#eee',

                    '--moment-input-bg-light': '#f0f0f0',
                    '--moment-input-border-light': '#ddd',
                    '--moment-card-bg-light': '#fff',
                    '--moment-card-border-light': '#eee',
                    '--moment-image-preview-bg': '#f9f9f9',
                    '--moment-name-color': '#333',
                    '--moment-content-color': '#444',
                    '--moment-comments-border': '#f0f0f0',
                    '--moment-comments-title-color': '#666',
                    '--comment-bg-light': '#f5f5f5',
                    '--comment-text-color': '#333',
                    '--comment-timestamp-color': '#999',

                    '--regenerate-modal-title-color': '#444',
                    '--regenerate-modal-body-color': '#555',
                    '--regenerate-modal-body-small-color': '#888',
                }
            },
            'starry-violet': { /* 新增主题：星空紫罗兰 */
                name: '星空紫罗兰 (深紫粉)',
                mainColors: ['#EFD4EB', '#C4B7D6', '#BBD6EE', '#454C72'], /* 调整为4个主色 */
                auxiliaryColors: {
                    '--text-color-dark': '#363C59', /* 最深的紫色 */
                    '--text-color-medium': '#454C72',
                    '--text-color-light': '#666', /* 保持中性灰，确保可读性 */
                    '--text-color-lighter': '#999', /* 保持中性灰 */
                    '--text-color-white': 'white',

                    '--header-text-shadow-color': 'rgba(255, 255, 255, 0.7)',
                    '--status-dot-online': '#4CAF50',
                    '--status-dot-busy': '#FFC107',
                    '--status-dot-offline': '#9E9E9E',

                    '--btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--btn-hover-bg': 'white',
                    '--btn-icon-color': '#555',

                    '--message-received-bubble-bg': 'white',
                    /* 修改：玩家气泡字体颜色为深色，以便在透明背景上显示 */
                    '--message-sent-bubble-text-color': '#363C59', 

                    '--retracted-bubble-bg': '#F5E8ED', /* 浅粉色 */
                    '--retracted-bubble-border': '#D87093', /* 略深的粉色 */
                    '--auto-reply-bubble-bg': '#E0F0F8', /* 浅蓝色 */
                    '--auto-reply-bubble-border': '#81C7D8', /* 略深的蓝色 */
                    '--auto-reply-label-bg': '#BBD6EE', /* 中等蓝色 */

                    '--input-area-bg': 'white',
                    '--toggle-input-btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--toggle-input-btn-hover-bg': 'white',
                    '--toggle-input-btn-icon-color': '#555',

                    '--modal-title-color': '#363C59', /* 深紫色 */
                    /* 修改：关闭按钮颜色为白色 */
                    '--close-btn-color': 'white', 
                    '--form-label-color': '#555',
                    '--upload-btn-color': 'white',
                    '--btn-primary-color': 'white',

                    '--inner-voice-color': '#9370db', /* 浅紫色 */
                    '--inner-voice-bg': '#F8F0F5', /* 极浅粉紫 */
                    '--inner-voice-shadow-rgb': '196, 183, 214', /* C4B7D6 的 RGB */

                    '--essay-text-color': '#363C59',
                    '--essay-bg': '#F5F0E8', /* 浅奶油色 */
                    '--essay-border': '#C4B7D6',
                    '--essay-pin-color': '#FFD700',

                    '--toggle-switch-off-bg': '#f0f0f0',
                    '--toggle-switch-border': '#ccc',
                    '--toggle-switch-handle-bg': 'white',

                    '--event-message-bg': 'rgba(128, 128, 128, 0.1)',
                    '--event-message-color': '#555',

                    '--persona-card-bg-light': '#f9f9f9',
                    '--persona-card-border-light': '#eee',

                    '--moment-input-bg-light': '#f0f0f0',
                    '--moment-input-border-light': '#ddd',
                    '--moment-card-bg-light': '#fff',
                    '--moment-card-border-light': '#eee',
                    '--moment-image-preview-bg': '#f9f9f9',
                    '--moment-name-color': '#333',
                    '--moment-content-color': '#444',
                    '--moment-comments-border': '#f0f0f0',
                    '--moment-comments-title-color': '#666',
                    '--comment-bg-light': '#f5f5f5',
                    '--comment-text-color': '#333',
                    '--comment-timestamp-color': '#999',

                    '--regenerate-modal-title-color': '#363C59',
                    '--regenerate-modal-body-color': '#454C72',
                    '--regenerate-modal-body-small-color': '#C4B7D6',

                    /* 修改：玩家气泡透明背景 */
                    '--message-sent-bubble-bg-gradient': 'rgba(var(--theme-color-rgb-2), 0.4)', /* 使用主题色2的RGB值，透明度为0.4 */
                    '--message-sent-bubble-border': '1px solid rgba(var(--theme-color-rgb-4), 0.6)', 
                }
            }
        };

        // IndexedDB 全局变量和辅助函数
        const DB_NAME = 'ChatSimulatorDB';
        const DB_VERSION = 1; // 数据库版本，如果修改了对象存储结构，需要递增此版本
        let db;

        /**
         * 打开IndexedDB数据库并创建/升级对象存储。
         * @returns {Promise<IDBDatabase>} 数据库实例
         */
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    // 创建或获取对象存储
                    if (!db.objectStoreNames.contains('userData')) {
                        db.createObjectStore('userData', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('friendData')) {
                        db.createObjectStore('friendData', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('apiConfig')) {
                        db.createObjectStore('apiConfig', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('appSettings')) {
                        db.createObjectStore('appSettings', { keyPath: 'id' });
                    }
                    // chatHistory 将存储每条消息，messageId 作为主键
                    if (!db.objectStoreNames.contains('chatHistory')) {
                        db.createObjectStore('chatHistory', { keyPath: 'messageId' });
                    }
                    // userMoments 将存储每条朋友圈动态，id 作为主键
                    if (!db.objectStoreNames.contains('userMoments')) {
                        db.createObjectStore('userMoments', { keyPath: 'id' });
                    }
                    // localRecords 将存储整个存档对象，id 作为主键
                    if (!db.objectStoreNames.contains('localRecords')) {
                        db.createObjectStore('localRecords', { keyPath: 'id' });
                    }
                    console.log('IndexedDB upgrade needed, stores created/updated.');
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('IndexedDB opened successfully.');
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        /**
         * 将数据存入IndexedDB。
         * @param {string} storeName 对象存储名称
         * @param {object} data 要存储的数据对象
         * @returns {Promise<void>}
         */
        function putData(storeName, data) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not open.');
                    return;
                }
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        /**
         * 从IndexedDB获取单条数据。
         * @param {string} storeName 对象存储名称
         * @param {string} key 数据的主键
         * @returns {Promise<object|undefined>} 获取到的数据对象
         */
        function getData(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not open.');
                    return;
                }
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);

                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        /**
         * 从IndexedDB获取所有数据。
         * @param {string} storeName 对象存储名称
         * @returns {Promise<Array<object>>} 获取到的数据数组
         */
        function getAllData(storeName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not open.');
                    return;
                }
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();

                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        /**
         * 从IndexedDB删除单条数据。
         * @param {string} storeName 对象存储名称
         * @param {string} key 要删除数据的主键
         * @returns {Promise<void>}
         */
        function deleteData(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not open.');
                    return;
                }
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        /**
         * 清空IndexedDB中的某个对象存储。
         * @param {string} storeName 对象存储名称
         * @returns {Promise<void>}
         */
        function clearStore(storeName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not open.');
                    return;
                }
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        // --- 番茄钟功能实现 ---

        /**
         * 格式化秒数为 MM:SS 字符串。
         * @param {number} seconds - 总秒数。
         * @returns {string} 格式化后的时间字符串。
         */
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        /**
         * 打开番茄钟设置弹窗。
         */
        function openPomodoroModal() {
            // 如果番茄钟正在进行，显示当前状态
            if (isPomodoroActive) {
                pomodoroGoalInput.value = pomodoroGoal;
                pomodoroGoalInput.disabled = true; // 目标不可编辑
                startPomodoroBtn.style.display = 'none'; // 隐藏开始按钮
                abandonPomodoroBtn.style.display = 'inline-block'; // 显示放弃按钮
                pomodoroStatusMessage.textContent = `专注目标：“${pomodoroGoal}”`;
                updateCountdownDisplay(); // 立即更新倒计时
            } else {
                // 如果番茄钟未进行，重置为初始状态
                pomodoroGoalInput.value = '';
                pomodoroGoalInput.disabled = false;
                startPomodoroBtn.style.display = 'inline-block';
                abandonPomodoroBtn.style.display = 'none';
                pomodoroStatusMessage.textContent = '设置你的专注目标：';
                pomodoroCountdownDisplay.textContent = '25:00';
            }
            openModal(pomodoroModal);
        }

        /**
         * 更新番茄钟倒计时显示。
         */
        function updateCountdownDisplay() {
            if (!isPomodoroActive) return;

            const now = Date.now();
            const timeLeftSeconds = Math.max(0, Math.floor((pomodoroEndTime - now) / 1000));

            pomodoroCountdownDisplay.textContent = formatTime(timeLeftSeconds);

            if (timeLeftSeconds <= 0) {
                stopPomodoroTimer('completed');
            }
        }

        /**
         * 开始番茄钟计时。
         */
        async function startPomodoro() {
            const goal = pomodoroGoalInput.value.trim();
            if (!goal) {
                showPomodoroNotification('请输入你的专注目标！');
                return;
            }

            pomodoroGoal = goal;
            pomodoroStartTime = Date.now();
            pomodoroEndTime = pomodoroStartTime + POMODORO_DURATION_SECONDS * 1000;
            isPomodoroActive = true;

            // 保存番茄钟状态到appSettings
            appSettings.pomodoro = {
                isActive: true,
                goal: pomodoroGoal,
                startTime: pomodoroStartTime,
                endTime: pomodoroEndTime
            };
            await putData('appSettings', appSettings);

            pomodoroGoalInput.disabled = true;
            startPomodoroBtn.style.display = 'none';
            abandonPomodoroBtn.style.display = 'inline-block';
            pomodoroStatusMessage.textContent = `专注目标：“${pomodoroGoal}”`;
            pomodoroBtn.classList.add('active-pomodoro');
            pomodoroBtn.title = `番茄钟：${pomodoroGoal} (专注中)`;

            updateCountdownDisplay(); // Initial display
            pomodoroTimer = setInterval(updateCountdownDisplay, 1000); // Update every second

            closeModal(pomodoroModal);
            showPomodoroNotification(`番茄钟已开始：${pomodoroGoal}`);
        }

        /**
         * 停止番茄钟计时器。
         * @param {string} status - 停止状态 ('completed', 'abandoned', 'reset')。
         */
        async function stopPomodoroTimer(status) { 
            if (pomodoroTimer) {
                clearInterval(pomodoroTimer);
                pomodoroTimer = null;
            }
            isPomodoroActive = false;
            pomodoroBtn.classList.remove('active-pomodoro');
            pomodoroBtn.title = `番茄钟`;

            // Reset appSettings.pomodoro state
            appSettings.pomodoro = {
                isActive: false,
                goal: '',
                startTime: null,
                endTime: null
            };
            await putData('appSettings', appSettings);

            pomodoroGoalInput.disabled = false;
            startPomodoroBtn.style.display = 'inline-block';
            abandonPomodoroBtn.style.display = 'none';
            pomodoroStatusMessage.textContent = '设置你的专注目标：';
            pomodoroCountdownDisplay.textContent = '25:00';

            if (status === 'completed') {
                showPomodoroNotification(`${pomodoroGoal} 已结束！恭喜你完成目标！`);
                // Trigger AI response for completion
                const aiPrompt = `玩家设置的番茄钟专注目标“${pomodoroGoal}”已于${new Date(pomodoroStartTime).toLocaleString()}开始，并于${new Date(pomodoroEndTime).toLocaleString()}成功完成。请你根据你的人设，对玩家完成目标的行为做出符合人设的回复。`;
                triggerAiResponseForPomodoro(aiPrompt, 'pomodoroComplete');
            } else if (status === 'abandoned') {
                showPomodoroNotification(`你放弃了目标：“${pomodoroGoal}”`);
                // Trigger AI response for abandonment
                const abandonTime = Date.now();
                const aiPrompt = `玩家设置的番茄钟专注目标“${pomodoroGoal}”已于${new Date(pomodoroStartTime).toLocaleString()}开始，但玩家在${new Date(abandonTime).toLocaleString()}选择了放弃。请你根据你的人设、玩家的目标、玩家专注的时间、设置专注目标的时间点是否合理(比如太晚了应该睡觉,不应该学习)，对玩家放弃目标的行为做出回复。`;
                triggerAiResponseForPomodoro(aiPrompt, 'pomodoroAbandon');
            }
            // 'reset' status means no AI response needed, just reset state (e.g., when starting new chat)
        }

        /**
         * 放弃番茄钟专注。
         * @param {boolean} triggerAi - 是否触发AI回复。
         */
        async function abandonPomodoro(triggerAi = false) {
            if (isPomodoroActive) {
                if (confirm(`确定要放弃当前专注目标“${pomodoroGoal}”吗？`)) {
                    stopPomodoroTimer('abandoned'); // This will trigger AI if triggerAi is true
                    closeModal(pomodoroModal);
                }
            } else {
                closeModal(pomodoroModal); // Simply close if not active
            }
        }

        /**
         * 恢复番茄钟计时器（例如在页面加载时）。
         */
        async function resumePomodoroTimer() {
            if (isPomodoroActive && pomodoroEndTime > Date.now()) {
                pomodoroTimer = setInterval(updateCountdownDisplay, 1000);
                updateCountdownDisplay(); // Initial update
            } else if (isPomodoroActive && pomodoroEndTime <= Date.now()) {
                // If it was active but already ended, trigger completion
                stopPomodoroTimer('completed');
            }
        }

        /**
         * 触发AI对番茄钟事件的回复。
         * @param {string} prompt - 发送给AI的提示文本。
         * @param {string} contextType - API调用的上下文类型。
         */
        async function triggerAiResponseForPomodoro(prompt, contextType) {
            const typingIndicatorContainer = document.createElement('div');
            typingIndicatorContainer.className = 'message received';
            typingIndicatorContainer.innerHTML = `
                <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                <div class="message-content">
                    <div class="name">${friendData.nickname || friendData.name}</div>
                    <div class="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;
            chatArea.appendChild(typingIndicatorContainer);
            scrollToBottom();

            try {
                const aiResponseText = await getApiResponse(contextType, prompt);
                const parsedAiData = parseAiResponse(aiResponseText);
                
                chatArea.removeChild(typingIndicatorContainer);
                await displayNewFriendMessages(parsedAiData, false, Date.now());

                appSettings.lastAiReplyTimestamp = Date.now();
                await putData('appSettings', appSettings);
                setFriendStatus('online');

            } catch (error) {
                chatArea.removeChild(typingIndicatorContainer);
                console.error(`AI回复番茄钟事件失败 (${contextType}):`, error);
                const errorMessage = `抱歉，我暂时无法对你的番茄钟事件做出回应。`;
                const errorMsgId = await saveBubbleToHistory(errorMessage, 'received', Date.now(), false, false, null, 'text'); // 修正 Date.2024 为 Date.now()
                addBubbleToDOM({
                    messageId: errorMsgId,
                    content: errorMessage,
                    type: 'received',
                    isRetracted: false,
                    isAutoReply: false,
                    timestamp: Date.now(),
                    displayTimeOverride: null,
                    segmentType: 'text',
                    cardData: null
                });
            }
        }

        // 初始化应用
        async function initApp() {
            await openDatabase(); // 确保数据库已打开
            await loadData();
            updateFriendNameInHeader();
            updateFriendStatusDisplay(true);
            document.querySelector('#inner-voice-modal .modal-title').textContent = `${friendData.name}的状态`;
            setupEventListeners();
            updateApiFields();
            scrollToBottom();
            checkAndTriggerAutoReply();
            await updateMomentsDisplay(); // 确保朋友圈显示更新
            applyTheme(appSettings.currentTheme); // 应用保存的主题
            applyChatBackground(appSettings.chatBackground.type, appSettings.chatBackground.value); // 应用保存的聊天背景

            // 恢复番茄钟状态
            if (appSettings.pomodoro.isActive) {
                pomodoroGoal = appSettings.pomodoro.goal;
                pomodoroStartTime = appSettings.pomodoro.startTime;
                pomodoroEndTime = appSettings.pomodoro.endTime;
                isPomodoroActive = true; // 确保全局变量同步
                
                const now = Date.now();
                if (pomodoroEndTime > now) {
                    // 计时器仍在进行中
                    resumePomodoroTimer();
                    pomodoroBtn.classList.add('active-pomodoro');
                    pomodoroBtn.title = `番茄钟：${pomodoroGoal} (专注中)`;
                    showPomodoroNotification(`番茄钟已恢复：${pomodoroGoal}`);
                } else {
                    // 计时器已过期
                    stopPomodoroTimer('completed'); // 这将触发完成逻辑和AI回复
                    showPomodoroNotification(`${pomodoroGoal} 已结束！`);
                }
            }
        }
        
        // 加载数据
        async function loadData() {
            // 从IndexedDB加载数据
            const savedUserData = await getData('userData', 'user');
            const savedFriendData = await getData('friendData', 'friend');
            const savedApiConfig = await getData('apiConfig', 'api');
            const savedAppSettings = await getData('appSettings', 'settings');
            const savedChatHistory = await getAllData('chatHistory'); // 获取所有聊天记录
            const savedUserMoments = await getAllData('userMoments'); // 获取所有朋友圈动态
            const savedLocalRecords = await getData('localRecords', 'slots'); // 获取本地记录存档

            if (savedUserData) userData = { ...userData, ...savedUserData };
            if (savedFriendData) {
                friendData = { ...friendData, ...savedFriendData };
                if (friendData.currentEssay === undefined) {
                    friendData.currentEssay = '暂无随笔。';
                }
                if (friendData.openingLine === undefined) {
                    friendData.openingLine = '';
                }
            }
            if (savedApiConfig) {
                apiConfig = { ...apiConfig, ...savedApiConfig };
            }
            if (savedAppSettings) {
                appSettings = { ...appSettings, ...savedAppSettings };
                if (appSettings.emojiDisplayMode === undefined) {
                    appSettings.emojiDisplayMode = 'image';
                }
                if (appSettings.innerVoiceFont === undefined) {
                    appSettings.innerVoiceFont = 'ma-shan-zheng';
                }
                if (appSettings.currentTheme === undefined) {
                    appSettings.currentTheme = 'default';
                }
                if (appSettings.chatBackground === undefined) {
                    appSettings.chatBackground = { type: 'default', value: 'default-chat-bg-1' };
                }
                if (appSettings.inputAreaShiftedUp === undefined) {
                    appSettings.inputAreaShiftedUp = false;
                }
                // 加载番茄钟状态
                if (appSettings.pomodoro === undefined) {
                    appSettings.pomodoro = { isActive: false, goal: '', startTime: null, endTime: null };
                }
            }
            if (savedUserMoments) {
                userMoments = savedUserMoments.sort((a, b) => b.timestamp - a.timestamp); // 按时间倒序排列
            }
            if (savedLocalRecords) {
                localRecords = { ...localRecords, ...savedLocalRecords };
                // 确保所有存档位都存在，即使是null
                for (let i = 1; i <= 3; i++) {
                    const slotId = `slot${i}`;
                    if (localRecords[slotId] === undefined) {
                        localRecords[slotId] = null;
                    }
                }
            }
            
            document.getElementById('user-name').value = userData.name;
            document.getElementById('user-gender').value = userData.gender;
            document.getElementById('user-avatar-preview').src = userData.avatar;
            document.getElementById('user-background').value = userData.background;
            document.getElementById("goal-label").textContent = `${userData.name}の目标`;
            
            innerVoiceFontSelect.value = appSettings.innerVoiceFont;
            applyInnerVoiceFont(appSettings.innerVoiceFont);

            essayFontSelect.value = appSettings.essayFont;
            applyEssayFont(appSettings.essayFont);

            inputAreaShiftUpSwitch.checked = appSettings.inputAreaShiftedUp; // 设置开关状态
            applyInputAreaShift(appSettings.inputAreaShiftedUp); // 应用输入栏上移设置
            
            updateFriendConfigModalUI();
            
            document.getElementById('api-provider').value = apiConfig.provider;
            document.getElementById('api-url').value = apiConfig.url;
            document.getElementById('api-key').value = apiConfig.key;
            document.getElementById('temperature').value = apiConfig.temperature;
            document.getElementById('persona-reminder-interval').value = apiConfig.personaReminderInterval;
            
            if (savedChatHistory && savedChatHistory.length > 0) {
                chatHistoryArray = savedChatHistory.sort((a, b) => a.timestamp - b.timestamp); // 按时间正序排列
                chatArea.innerHTML = '';
                chatHistoryArray.forEach(bubble => {
                    if (bubble.type === 'event') {
                        addEventMessageToDOM(bubble.content, bubble.messageId);
                    } else {
                        // 使用新的 addBubbleToDOM 函数来处理所有消息类型
                        addBubbleToDOM(bubble);
                    }
                });
                userMessageCounter = chatHistoryArray.filter(bubble => bubble.type === 'sent').length;
                scrollToBottom();
            } else {
                userMessageCounter = 0;
                buildFriendPersonaPrompt();
                initiateChatWithPersona();
            }
            document.getElementById('inner-voice-display').textContent = currentInnerVoice;
            document.getElementById('essay-display').textContent = friendData.currentEssay;
        }
        
            
        // 设置事件监听器
        function setupEventListeners() {
            sendBtn.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            document.getElementById('manage-btn').addEventListener('click', () => openModal(manageModal));
            document.getElementById('manage-user-config-btn').addEventListener('click', () => { closeModal(manageModal); openModal(userModal); });
            document.getElementById('manage-friend-config-btn').addEventListener('click', () => { closeModal(manageModal); updateFriendConfigModalUI(); openModal(friendModal); });
            document.getElementById('manage-api-config-btn').addEventListener('click', () => { closeModal(manageModal); updateApiFields(); openModal(apiModal); });
            document.getElementById('manage-all-settings-btn').addEventListener('click', () => { 
                closeModal(manageModal); 
                autoReplySwitch.checked = appSettings.autoReplyEnabled; 
                inputAreaShiftUpSwitch.checked = appSettings.inputAreaShiftedUp; // 设置输入栏上移开关状态
                innerVoiceFontSelect.value = appSettings.innerVoiceFont;
                essayFontSelect.value = appSettings.essayFont;
                emojiDisplayModeSelect.value = appSettings.emojiDisplayMode;
                openModal(allSettingsModal); 
            });
            document.getElementById('manage-persona-selection-btn').addEventListener('click', () => {
                closeModal(manageModal);
                populatePersonaSelectionModal();
                openModal(personaSelectionModal);
            });
            // 新增：主题设置按钮事件
            manageThemeSettingsBtn.addEventListener('click', () => {
                closeModal(manageModal);
                populateThemeOptions(); // 填充主题选项和背景选项
                openModal(themeSettingsModal);
            });
            // 新增：本地记录按钮事件
            manageLocalRecordsBtn.addEventListener('click', () => {
                closeModal(manageModal);
                populateLocalRecordsModal(); // 填充本地记录存档位
                openModal(localRecordsModal);
            });


            document.getElementById('friend-status-btn').addEventListener('click', () => {
                document.getElementById('inner-voice-display').textContent = currentInnerVoice;
                document.getElementById('essay-display').textContent = friendData.currentEssay;
                openModal(innerVoiceModal);
            });

            momentsBtn.addEventListener('click', async () => {
                await updateMomentsDisplay(); // 确保朋友圈显示更新
                openModal(momentsModal);
            });
            
            document.getElementById('close-user-modal').addEventListener('click', () => closeModal(userModal));
            document.getElementById('close-friend-modal').addEventListener('click', () => closeModal(friendModal));
            document.getElementById('close-api-modal').addEventListener('click', () => closeModal(apiModal));
            document.getElementById('close-inner-voice-modal').addEventListener('click', () => closeModal(innerVoiceModal));
            document.getElementById('close-all-settings-modal').addEventListener('click', () => closeModal(allSettingsModal)); 
            document.getElementById('close-manage-modal').addEventListener('click', () => closeModal(manageModal));
            document.getElementById('close-persona-selection-modal').addEventListener('click', () => closeModal(personaSelectionModal));
            document.getElementById('close-persona-detail-modal').addEventListener('click', () => closeModal(personaDetailModal));
            document.getElementById('close-moments-modal').addEventListener('click', () => closeModal(momentsModal));
            closeRegenerateModalBtn.addEventListener('click', () => closeModal(regenerateModal));
            cancelRegenerateBtn.addEventListener('click', () => closeModal(regenerateModal));
            confirmRegenerateBtn.addEventListener('click', handleRegenerate);
            // 新增：主题设置弹窗关闭按钮
            closeThemeSettingsModalBtn.addEventListener('click', () => closeModal(themeSettingsModal));
            // 新增：本地记录弹窗关闭按钮
            closeLocalRecordsModalBtn.addEventListener('click', () => closeModal(localRecordsModal));

            // 新增：番茄钟事件监听器
            pomodoroBtn.addEventListener('click', openPomodoroModal);
            
            // 新增：表情包按钮事件
            emojiBtn.addEventListener('click', toggleEmojiCard);
            prevEmojiPageBtn.addEventListener('click', goToPrevEmojiPage);
            nextEmojiPageBtn.addEventListener('click', goToNextEmojiPage);
            emojiGrid.addEventListener('click', handleEmojiClick); // 使用事件委托
            
            closePomodoroModalBtn.addEventListener('click', () => closeModal(pomodoroModal));
            startPomodoroBtn.addEventListener('click', startPomodoro);
            abandonPomodoroBtn.addEventListener('click', () => abandonPomodoro(true)); // Pass true to trigger AI response


            document.getElementById('cancel-user-btn').addEventListener('click', () => closeModal(userModal));
            document.getElementById('cancel-friend-btn').addEventListener('click', () => closeModal(friendModal));
            document.getElementById('cancel-api-btn').addEventListener('click', () => closeModal(apiModal));
            
            document.getElementById('save-user-btn').addEventListener('click', saveUserData);
            document.getElementById('save-api-btn').addEventListener('click', saveApiConfig);
            document.getElementById('save-friend-only-btn').addEventListener('click', saveFriendDataOnly);
            document.getElementById('save-friend-and-chat-btn').addEventListener('click', saveFriendDataAndStartNewChat);
            
            document.getElementById('user-upload-btn').addEventListener('click', () => document.getElementById('user-avatar-upload').click());
            document.getElementById('friend-upload-btn').addEventListener('click', () => document.getElementById('friend-avatar-upload').click());
            
            document.getElementById('user-avatar-upload').addEventListener('change', (e) => handleImageUpload(e, 'user-avatar-preview'));
            document.getElementById('friend-avatar-upload').addEventListener('change', (e) => handleImageUpload(e, 'friend-avatar-preview'));
            
            document.getElementById('api-provider').addEventListener('change', updateApiFields);
            
            document.addEventListener('click', createRippleEffect);

            chatArea.addEventListener('dblclick', async (e) => {
                console.log('dblclick event triggered on chatArea');
                const target = e.target;
                console.log('Event target:', target);
                console.log('Target classList:', target.classList);
                const closestReceivedMessage = target.closest('.message.received');
                console.log('Closest .message.received:', closestReceivedMessage);

                // 修正：确保点击的是头像，并且该头像属于“收到的消息”气泡
                if (target.classList.contains('avatar') && closestReceivedMessage) {
                    console.log('Conditions met: avatar clicked within a received message.');
                    e.preventDefault();

                    const pokeAction = friendData.pokeAction || '拍了拍';
                    const pokeContent = friendData.pokeContent ? `，${friendData.pokeContent}` : '';
                    const pokeMessageText = `我${pokeAction}${friendData.nickname || friendData.name}${pokeContent}`;
                    
                    const pokeMsgId = await saveBubbleToHistory(pokeMessageText, 'event', Date.now(), false, false, null, 'text');
                    addEventMessageToDOM(pokeMessageText, pokeMsgId);

                    const typingIndicatorContainer = document.createElement('div');
                    typingIndicatorContainer.className = 'message received';
                    typingIndicatorContainer.innerHTML = `
                        <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                        <div class="message-content">
                            <div class="name">${friendData.nickname || friendData.name}</div>
                            <div class="typing-indicator">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        </div>
                    `;
                    chatArea.appendChild(typingIndicatorContainer);
                    scrollToBottom();

                    try {
                        const aiPrompt = `用户对你进行了“拍一拍”操作，内容是：“${pokeMessageText}”。这类似于QQ的“拍一拍”功能，在你的视角里，拍一拍的内容其实是你自己设定的，请你根据你的人设对此做出回应。请严格遵循消息格式：
                        用""将回复内容分成多个短句，例如："嗯？""今天天气真不错"；并在最后附上心声【心声：心声内容不超过30字】`;
                        
                        const aiResponseText = await getApiResponse('poke', aiPrompt); 
                        const parsedAiData = parseAiResponse(aiResponseText);
                        
                        chatArea.removeChild(typingIndicatorContainer);
                        await displayNewFriendMessages(parsedAiData, false, Date.now());

                        appSettings.lastAiReplyTimestamp = Date.now();
                        await putData('appSettings', appSettings);
                        setFriendStatus('online');

                    } catch (error) {
                        chatArea.removeChild(typingIndicatorContainer);
                        console.error('拍一拍回复失败:', error);
                        const errorMessage = '抱歉，拍一拍回复失败。请检查API配置或稍后再试。';
                        const errorMsgId = await saveBubbleToHistory(errorMessage, 'received', Date.now(), false, false, null, 'text');
                        addBubbleToDOM({
                            messageId: errorMsgId,
                            content: errorMessage,
                            type: 'received',
                            isRetracted: false,
                            isAutoReply: false,
                            timestamp: Date.now(),
                            displayTimeOverride: null,
                            segmentType: 'text',
                            cardData: null
                        });
                    }
                } else {
                    console.log('Conditions NOT met for poke: target is not avatar or not within a received message.');
                }
            });

            chatArea.addEventListener('click', async (e) => {
                const target = e.target;
                if (target.classList.contains('avatar') && target.closest('.message.sent')) {
                    const clickedMessageElement = target.closest('.message.sent');
                    if (clickedMessageElement) {
                        const clickedMessageId = clickedMessageElement.dataset.messageId;
                        let userMsgIndex = -1;
                        for (let i = 0; i < chatHistoryArray.length; i++) {
                            if (chatHistoryArray[i].messageId === clickedMessageId) {
                                userMsgIndex = i;
                                break;
                            }
                        }

                        if (userMsgIndex !== -1) {
                            const userMessageContent = chatHistoryArray[userMsgIndex].content;
                            const aiMessagesToClear = [];
                            const aiMessageDomElementsToClear = [];

                            for (let i = userMsgIndex + 1; i < chatHistoryArray.length; i++) {
                                if (chatHistoryArray[i].type === 'received') {
                                    aiMessagesToClear.push(chatHistoryArray[i].messageId);
                                    const domEl = chatArea.querySelector(`[data-message-id="${chatHistoryArray[i].messageId}"]`);
                                    if (domEl) {
                                        aiMessageDomElementsToClear.push(domEl);
                                    }
                                } else {
                                    break;
                                }
                            }

                            if (aiMessagesToClear.length === 0) {
                                showNotification('没有AI回复可以重新生成。');
                                return;
                            }

                            window.currentRegenerationContext = {
                                userMessageContent: userMessageContent,
                                aiMessageIdsToClear: aiMessagesToClear,
                                aiMessageDomElementsToClear: aiMessageDomElementsToClear,
                                userMessageHistoryIndex: userMsgIndex
                            };

                            openModal(regenerateModal);
                        }
                    }
                }
            });

            toggleInputBtn.addEventListener('click', () => {
                isInputExpanded = !isInputExpanded;
                messageInput.classList.toggle('expanded', isInputExpanded);
                arrowIcon.textContent = isInputExpanded ? '🌻' : '🌷';
                
                if (isInputExpanded) {
                    messageInput.focus();
                    messageInput.scrollTop = messageInput.scrollHeight;
                }
            });

            autoReplySwitch.addEventListener('change', async () => {
                appSettings.autoReplyEnabled = autoReplySwitch.checked;
                await putData('appSettings', appSettings);
                console.log('自动回复状态已更新:', appSettings.autoReplyEnabled ? '开启' : '关闭');
            });

            // 新增：输入栏上移开关事件监听器
            inputAreaShiftUpSwitch.addEventListener('change', async () => {
                appSettings.inputAreaShiftedUp = inputAreaShiftUpSwitch.checked;
                await putData('appSettings', appSettings);
                applyInputAreaShift(appSettings.inputAreaShiftedUp);
                console.log('输入栏上移状态已更新:', appSettings.inputAreaShiftedUp ? '开启' : '关闭');
            });

            innerVoiceFontSelect.addEventListener('change', async (e) => {
                appSettings.innerVoiceFont = e.target.value;
                await putData('appSettings', appSettings);
                applyInnerVoiceFont(appSettings.innerVoiceFont);
            });

            essayFontSelect.addEventListener('change', async (e) => {
                appSettings.essayFont = e.target.value;
                await putData('appSettings', appSettings);
                applyEssayFont(appSettings.essayFont);
            });

            emojiDisplayModeSelect.addEventListener('change', async (e) => {
                appSettings.emojiDisplayMode = e.target.value;
                await putData('appSettings', appSettings);
                buildFriendPersonaPrompt();
                console.log('表情包显示方式已更新:', appSettings.emojiDisplayMode);
            });

            document.getElementById('apply-persona-from-detail-btn').addEventListener('click', async (e) => {
                const personaId = e.target.dataset.personaId;
                const selectedPersona = predefinedPersonas.find(p => p.id === personaId);
                if (selectedPersona) {
                    await applyPersona(selectedPersona);
                    closeModal(personaDetailModal);
                }
            });

            uploadMomentImageBtn.addEventListener('click', () => momentImageUpload.click());
            momentImageUpload.addEventListener('change', handleMomentImageUpload);
            removeMomentImageBtn.addEventListener('click', removeMomentImage);
            publishMomentBtn.addEventListener('click', publishMoment);

            // 新增：聊天背景设置事件监听器
            uploadChatBackgroundBtn.addEventListener('click', () => chatBackgroundUploadInput.click());
            chatBackgroundUploadInput.addEventListener('change', handleChatBackgroundUpload);
            removeChatBackgroundBtn.addEventListener('click', removeChatBackground);
            defaultChatBackgroundSelect.addEventListener('change', handleDefaultChatBackgroundChange);
        }
        
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;
            
            messageInput.value = '';
            
            const now = Date.now();
            const segments = message.match(/“(.*?)”/g); 
            let displayDelay = 0; 

            if (segments && segments.length > 0) {
                for (const segment of segments) {
                    const content = segment.substring(1, segment.length - 1).trim(); 
                    if (content === '') continue; 

                    await new Promise(resolve => {
                        setTimeout(async () => {
                            const msgId = await saveBubbleToHistory(content, 'sent', now, false, false, null, 'text');
                            addBubbleToDOM({
                                messageId: msgId,
                                content: content,
                                type: 'sent',
                                isRetracted: false,
                                isAutoReply: false,
                                timestamp: now,
                                displayTimeOverride: null,
                                segmentType: 'text',
                                cardData: null
                            });
                            resolve();
                        }, displayDelay);
                    });
                    displayDelay += 800; 
                }
            } else {
                const msgId = await saveBubbleToHistory(message, 'sent', now, false, false, null, 'text');
                addBubbleToDOM({
                    messageId: msgId,
                    content: message,
                    type: 'sent',
                    isRetracted: false,
                    isAutoReply: false,
                    timestamp: now,
                    displayTimeOverride: null,
                    segmentType: 'text',
                    cardData: null
                });
            }

            userMessageCounter++;
            
            const typingIndicatorContainer = document.createElement('div');
            typingIndicatorContainer.className = 'message received';
            typingIndicatorContainer.innerHTML = `
                <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                <div class="message-content">
                    <div class="name">${friendData.nickname || friendData.name}</div>
                    <div class="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;
            chatArea.appendChild(typingIndicatorContainer);
            scrollToBottom();
            
            let aiPromptModifier = '';
            if (isPomodoroActive) {
                const now = Date.now();
                const minutesLeft = Math.max(0, Math.floor((pomodoroEndTime - now) / 1000 / 60));
                aiPromptModifier = `玩家当前正在进行番茄钟专注，目标是“${pomodoroGoal}”，已于${new Date(pomodoroStartTime).toLocaleString()}开始，还剩约${minutesLeft}分钟结束。请你针对玩家的这种分心行为，结合玩家的目标、时长、设置番茄钟的时间点是否合理(比如已经很晚了还要选择学习等行为)，根据你的人设给出回复。`;
            }

            try {
                const aiResponseText = await getApiResponse('chat', aiPromptModifier); // Pass modifier to getApiResponse
                const parsedAiData = parseAiResponse(aiResponseText);
                
                chatArea.removeChild(typingIndicatorContainer);
                await displayNewFriendMessages(parsedAiData, false, Date.now());

                appSettings.lastAiReplyTimestamp = Date.now();
                await putData('appSettings', appSettings);
                setFriendStatus('online');

            } catch (error) {
                chatArea.removeChild(typingIndicatorContainer);
                console.error('API调用失败:', error);
                const errorMessage = '抱歉，我暂时无法回复。请检查API配置或稍后再试。';
                const errorMsgId = await saveBubbleToHistory(errorMessage, 'received', Date.now(), false, false, null, 'text');
                addBubbleToDOM({
                    messageId: errorMsgId,
                    content: errorMessage,
                    type: 'received',
                    isRetracted: false,
                    isAutoReply: false,
                    timestamp: Date.now(),
                    displayTimeOverride: null,
                    segmentType: 'text',
                    cardData: null
                });
            }
        }
        
        /**
         * 生成卡片消息的HTML结构。
         * @param {object} cardData - 包含 friendName, shareType, shareTitle, shareDescription 的对象。
         * @param {string} messageType - 消息类型 ('sent' 或 'received')，用于决定左侧图片颜色。
         * @returns {string} 卡片消息的HTML字符串。
         */
        function generateCardHtml(cardData, messageType) {
            const { friendName, shareType, shareTitle, shareDescription } = cardData;
            // 根据消息类型选择左侧图片的主题色
            const cardImageColor = messageType === 'received' ? 'var(--theme-color-1)' : 'var(--theme-color-2)';

            return `
                <div class="card-message-inner">
                    <div class="card-left-image" style="background-color: ${cardImageColor};"></div>
                    <div class="card-content-area">
                        <div class="card-title">${shareTitle}</div>
                        <div class="card-description">${shareDescription}</div>
                        <div class="card-type-label">${shareType}</div>
                    </div>
                </div>
            `;
        }

        /**
         * 将消息气泡添加到DOM中。
         * @param {object} bubbleData - 包含消息所有数据的对象。
         * @param {string} bubbleData.content - 消息内容（文本、表情ID或卡片JSON字符串）。
         * @param {string} bubbleData.type - 消息类型 ('sent' 或 'received')。
         * @param {boolean} [bubbleData.isRetracted=false] - 是否为撤回消息。
         * @param {boolean} [bubbleData.isAutoReply=false] - 是否为自动回复。
         * @param {number} bubbleData.timestamp - 消息时间戳。
         * @param {string|null} [bubbleData.displayTimeOverride=null] - 自动回复时用于显示的时间字符串。
         * @param {string} [bubbleData.segmentType='text'] - 消息段类型 ('text', 'emoji-image', 'card')。
         * @param {string|null} [bubbleData.messageId=null] - 消息的唯一ID。
         * @param {object|null} [bubbleData.cardData=null] - 如果是卡片消息，包含卡片详细数据的对象。
         */
        function addBubbleToDOM(bubbleData) {
            const { content, type, isRetracted = false, isAutoReply = false, timestamp, displayTimeOverride = null, segmentType = 'text', messageId = null, cardData = null } = bubbleData;

            let displayTimeText;
            if (isAutoReply && displayTimeOverride) {
                displayTimeText = displayTimeOverride;
            } else {
                const displayTime = new Date(timestamp);
                displayTimeText = `${displayTime.getHours().toString().padStart(2, '0')}:${displayTime.getMinutes().toString().padStart(2, '0')}`;
            }
            
            const messageContainer = document.createElement('div');
            messageContainer.className = `message ${type}`;
            if (messageId) {
                messageContainer.dataset.messageId = messageId;
            }
            
            const name = type === 'sent' ? userData.name : (friendData.nickname || friendData.name);
            const avatar = type === 'sent' ? userData.avatar : friendData.avatar;
            
            let retractedTagHtml = '';
            let bubbleClasses = 'bubble';
            let autoReplyLabelHtml = '';
            let bubbleContentHtml = '';

            if (isRetracted) {
                retractedTagHtml = `<div class="retracted-tag">(撤回)</div>`;
                bubbleClasses += ' retracted-bubble';
            }
            if (isAutoReply) {
                bubbleClasses += ' auto-reply-bubble';
                autoReplyLabelHtml = `<span class="auto-reply-label">未读消息</span>`;
            }

            if (segmentType === 'emoji-image') {
                const emojiId = content; // content is the emoji ID
                const emojiName = PLAYER_EMOJI_MAP[emojiId] || '未知表情';

                if (appSettings.emojiDisplayMode === 'image') {
                    bubbleClasses += ' emoji-bubble';
                    const imageUrl = `https://z.wiki/u/${emojiId}`;
                    bubbleContentHtml = `<img src="${imageUrl}" alt="${emojiName}">`;
                } else {
                    bubbleContentHtml = `[表情: ${emojiName}]`;
                }
            } else if (segmentType === 'card') {
                bubbleClasses += ' card-bubble'; // 为卡片消息添加特定类
                // cardData 已经是解析后的对象，直接传递给生成函数
                bubbleContentHtml = generateCardHtml(cardData, type);
            } else { // segmentType === 'text'
                bubbleContentHtml = content;
            }

            messageContainer.innerHTML = `
                <img src="${avatar}" alt="${name}头像" class="avatar">
                <div class="message-content">
                    <div class="name">${name}</div>
                    <div class="bubble-and-tag-wrapper"> 
                        <div class="${bubbleClasses}">${bubbleContentHtml}</div>
                        ${retractedTagHtml}
                    </div>
                </div>
            `;
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'timestamp';
            timestampDiv.innerHTML = `${displayTimeText}${autoReplyLabelHtml}`;
            
            messageContainer.querySelector('.message-content').appendChild(timestampDiv);

            chatArea.appendChild(messageContainer);
            scrollToBottom();
        }

        function addEventMessageToDOM(text, messageId = null) {
            const messageContainer = document.createElement('div');
            messageContainer.className = 'message event-message';
            if (messageId) {
                messageContainer.dataset.messageId = messageId;
            }

            messageContainer.innerHTML = `
                <div class="message-content">
                    <div class="bubble">${text}</div>
                </div>
            `;
            
            chatArea.appendChild(messageContainer);
            scrollToBottom();
        }
        
        /**
         * 将消息气泡数据保存到历史记录和IndexedDB。
         * @param {string} content - 消息内容（文本、表情ID或卡片JSON字符串）。
         * @param {string} type - 消息类型 ('sent', 'received', 'event')。
         * @param {number} timestamp - 消息时间戳。
         * @param {boolean} [isRetracted=false] - 是否为撤回消息。
         * @param {boolean} [isAutoReply=false] - 是否为自动回复。
         * @param {string|null} [displayTimeOverride=null] - 自动回复时用于显示的时间字符串。
         * @param {string} [segmentType='text'] - 消息段类型 ('text', 'emoji-image', 'card')。
         * @param {object|null} [cardData=null] - 如果是卡片消息，包含卡片详细数据的对象。
         * @returns {Promise<string>} 消息的唯一ID。
         */
        async function saveBubbleToHistory(content, type, timestamp, isRetracted = false, isAutoReply = false, displayTimeOverride = null, segmentType = 'text', cardData = null) {
            const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const bubbleData = {
                messageId: messageId,
                content: content, // 对于卡片消息，这里存储的是 stringified JSON
                type: type,
                timestamp: timestamp,
                isRetracted: isRetracted,
                isAutoReply: isAutoReply,
                displayTimeOverride: displayTimeOverride,
                segmentType: segmentType,
                cardData: cardData // 直接存储解析后的卡片数据对象
            };
            chatHistoryArray.push(bubbleData); // Update in-memory cache
            await putData('chatHistory', bubbleData); // Save to IndexedDB
            return messageId;
        }

        /**
         * 解析AI返回的原始文本，提取消息段、心声、随笔和朋友圈评论。
         * @param {string} fullAiResponseText - AI返回的原始文本。
         * @returns {object} 包含解析后数据的对象。
         */
        function parseAiResponse(fullAiResponseText) {
            console.log("--- Parsing AI Response ---");
            console.log("Raw AI Response Text (before parsing):", fullAiResponseText);
            const parsedSegments = [];
            let innerVoice = '暂无心声。';
            let essay = '暂无随笔。';
            const momentComments = [];

            // 1. 提取心声
            const innerVoiceMatch = fullAiResponseText.match(/【心声：(.*?)】/);
            if (innerVoiceMatch && innerVoiceMatch[1]) {
                innerVoice = innerVoiceMatch[1].trim();
                fullAiResponseText = fullAiResponseText.replace(/【心声：.*?】/, '').trim();
                console.log("Extracted Heart Voice:", innerVoice);
            }

            // 2. 提取随笔
            const essayMatch = fullAiResponseText.match(/「随笔：(.*?)」/);
            if (essayMatch && essayMatch[1]) {
                essay = essayMatch[1].trim();
                fullAiResponseText = fullAiResponseText.replace(/「随笔：.*?」/, '').trim();
                console.log("Extracted Essay:", essay);
            }

            // 3. 提取朋友圈评论
            const commentRegex = /(?:【评论：(.*?)】)|(?:〖(.*?)：(.*?)〗)/g;
            let commentMatch;
            const commentsToRemove = []; // 临时存储匹配到的完整评论字符串，以便从原始文本中移除
            while ((commentMatch = commentRegex.exec(fullAiResponseText)) !== null) {
                commentsToRemove.push(commentMatch[0]); // 存储匹配到的完整字符串
                if (commentMatch[1] !== undefined) { // AI自己的评论
                    momentComments.push({
                        type: 'ai',
                        name: friendData.nickname || friendData.name,
                        avatar: friendData.avatar,
                        content: commentMatch[1].trim()
                    });
                    console.log("Extracted AI Comment:", commentMatch[1].trim());
                } else if (commentMatch[2] !== undefined && commentMatch[3] !== undefined) { // 其他好友评论
                    momentComments.push({
                        type: 'other',
                        name: commentMatch[2].trim(),
                        avatar: getRandomAvatar(),
                        content: commentMatch[3].trim()
                    });
                    console.log("Extracted Other Friend Comment:", commentMatch[2].trim(), commentMatch[3].trim());
                }
            }
            // 从原始文本中移除所有评论
            commentsToRemove.forEach(commentStr => {
                fullAiResponseText = fullAiResponseText.replace(commentStr, '');
            });
            fullAiResponseText = fullAiResponseText.trim(); // 再次trim以清除多余空格

            // 4. 解析主要消息段
            // 顺序很重要：卡片消息 -> 表情包 -> 撤回消息 -> 普通引用消息 -> 剩余文本
            // 修正了卡片消息和撤回消息的正则表达式，并调整了捕获组索引。
            const segmentRegex = /『([^|]+)\|([^|]+)\|(.*?)』|<bqb>(.*?)<\/bqb>|\{([^}]+)\}|"(.*?)(?:\|(\d{2}:\d{2}))?"|([^"『【「<\{]+)/g;
            segmentRegex.lastIndex = 0; // 重置正则表达式的lastIndex，以便多次匹配

            let match;
            let hasStructuredSegments = false; // 标记是否找到任何结构化消息段

            while ((match = segmentRegex.exec(fullAiResponseText)) !== null) {
                let content;
                let segmentType = 'text';
                let isRetracted = false;
                let customTime = null;
                let cardData = null; // 用于存储卡片消息的详细数据

                // 卡片消息: 『分享类型|分享标题|分享内容简介』 (match[1], match[2], match[3])
                if (match[1] !== undefined) {
                    segmentType = 'card';
                    cardData = {
                        shareType: match[1].trim(),
                        shareTitle: match[2].trim(),
                        shareDescription: match[3].trim()
                    };
                    content = JSON.stringify(cardData); // 将卡片数据JSON字符串化存储在content中
                    hasStructuredSegments = true;
                }
                // 表情包: <bqb>id</bqb> (match[4])
                else if (match[4] !== undefined) {
                    content = match[4].trim();
                    segmentType = 'emoji-image';
                    hasStructuredSegments = true;
                }
                // 撤回消息: {撤回的文字消息} (match[5])
                else if (match[5] !== undefined) {
                    content = match[5].trim(); // 实际的撤回文本
                    isRetracted = true;
                    segmentType = 'text'; // 仍然是文本类型，只是被撤回
                    hasStructuredSegments = true;
                }
                // 普通引用消息: "content" 或 "content|HH:MM" (match[6], match[7])
                else if (match[6] !== undefined) {
                    content = match[6].trim();
                    if (match[7] !== undefined) {
                        customTime = match[7];
                    }
                    segmentType = 'text';
                    hasStructuredSegments = true;
                }
                // 兜底：纯文本 (match[8])
                else if (match[8] !== undefined) {
                    content = match[8].trim();
                    segmentType = 'text';
                    // 只有当内容非空时才标记为结构化消息
                    if (content !== '') {
                        hasStructuredSegments = true;
                    }
                } else {
                    continue; // 理论上不应该发生，如果正则表达式全面
                }

                if (content === '' && segmentType !== 'card') { // 卡片消息可以有空描述，但其他类型不能有空内容
                    console.log("Skipping empty content segment.");
                    continue;
                }

                parsedSegments.push({ content, isRetracted, customTime, type: segmentType, cardData });
            }

            // 如果没有找到任何结构化消息段，但原始文本仍有内容，则将其视为一个普通文本段
            if (!hasStructuredSegments && fullAiResponseText.trim() !== '') {
                console.log("No structured segments found, treating remaining text as single segment.");
                parsedSegments.push({ content: fullAiResponseText.trim(), isRetracted: false, customTime: null, type: 'text', cardData: null });
            }
            console.log("Final Parsed Segments:", parsedSegments);
            console.log("Final Parsed Moment Comments:", momentComments);
            console.log("--- End Parsing AI Response ---");
            return { segments: parsedSegments, innerVoice: innerVoice, essay: essay, momentComments: momentComments };
        }
        
        async function displayNewFriendMessages(parsedData, isAutoReply = false, baseTimestamp = Date.now()) {
            const { segments, innerVoice, essay } = parsedData;
            
            currentInnerVoice = innerVoice; 
            document.getElementById('inner-voice-display').textContent = currentInnerVoice;

            const aiProvidedEssay = (essay && essay !== '暂无随笔。' && essay.trim() !== '');

            if (aiProvidedEssay) {
                const essayChanged = essay !== friendData.currentEssay;
                if (essayChanged) {
                    friendData.currentEssay = essay; 
                    await putData('friendData', friendData); // Save updated friendData
                }
                document.getElementById('essay-display').textContent = essay;

                showNotification(`${friendData.nickname || friendData.name} 新增了一条随笔`); 
            } else {
                document.getElementById('essay-display').textContent = friendData.currentEssay;
            }

            let visualDisplayDelay = 0;
            let lastSegmentTimestamp = baseTimestamp;

            for (const segment of segments) {
                let segmentTimestamp;
                let displayTimeOverride = null;

                if (isAutoReply && segment.customTime) {
                    displayTimeOverride = segment.customTime;
                    const [hours, minutes] = segment.customTime.split(':').map(Number);
                    
                    let tempDate = new Date(lastSegmentTimestamp);
                    tempDate.setHours(hours, minutes, 0, 0);

                    if (tempDate.getTime() < lastSegmentTimestamp) {
                        tempDate.setDate(tempDate.getDate() + 1);
                    }
                    segmentTimestamp = tempDate.getTime();
                    lastSegmentTimestamp = segmentTimestamp;
                } else {
                    segmentTimestamp = Date.now(); 
                }
                
                // 对于卡片消息，content 存储的是 stringified JSON，cardData 存储的是对象
                const contentToSave = segment.type === 'card' ? JSON.stringify(segment.cardData) : segment.content;

                const msgId = await saveBubbleToHistory(
                    contentToSave,
                    'received',
                    segmentTimestamp,
                    segment.isRetracted,
                    isAutoReply,
                    displayTimeOverride,
                    segment.type,
                    segment.cardData // 传递 cardData 对象
                );

                await new Promise(resolve => {
                    setTimeout(() => {
                        // 传递完整的 bubbleData 对象给 addBubbleToDOM
                        addBubbleToDOM({
                            messageId: msgId,
                            content: contentToSave,
                            type: 'received',
                            isRetracted: segment.isRetracted,
                            isAutoReply: isAutoReply,
                            timestamp: segmentTimestamp,
                            displayTimeOverride: displayTimeOverride,
                            segmentType: segment.type,
                            cardData: segment.cardData // 确保 cardData 被传递
                        });
                        resolve();
                    }, visualDisplayDelay);
                });
                visualDisplayDelay += 800;
            }
        }

        function scrollToBottom() {
            chatArea.scrollTop = chatArea.scrollHeight;
        }
        
        function openModal(modal) {
            modal.classList.add('active');
        }
        
        function closeModal(modal) {
            modal.classList.remove('active');
        }
        
        async function saveUserData() {
            userData.name = document.getElementById('user-name').value || '我';
            userData.gender = document.getElementById('user-gender').value;
            userData.avatar = document.getElementById('user-avatar-preview').src;
            userData.background = document.getElementById('user-background').value;
            
            await putData('userData', userData);
            closeModal(userModal);
        }

        function buildFriendPersonaPrompt() {
            const playerAddressForAI = friendData.playerAddress || userData.name;
            let personaPrompt = `你现在是一个名为"${friendData.name}"（备注：${friendData.nickname || '无'}）的AI助手。
你的性别是${friendData.gender === 'male' ? '男' : (friendData.gender === 'female' ? '女' : '其他')}。
你的喜好是：${friendData.likes || '无'}。
你的厌恶是：${friendData.dislikes || '无'}。
你的习惯是：${friendData.habits || '无'}。
你对用户的称呼是：${friendData.playerAddress || '无'}。
你的背景资料是：${friendData.background || '无'}。

与你对话的用户名为"${userData.name}"。
用户的性别是${userData.gender === 'male' ? '男' : (userData.gender === 'female' ? '女' : '其他')}。
用户的背景资料是：${userData.background || '无'}。

请根据这些信息，以"${friendData.nickname || friendData.name}"的身份与用户"${playerAddressForAI}"进行自然的对话。**在称呼上不要混淆用户和你的性别**，尽量避免说出和上一次回复时重复度较高的话。
**重要回复格式说明：**
1.  **普通回复**：请将你的普通回复拆分成多个通畅的短句，每个短句都用英文双引号包裹，并紧密连接，例如："你好！""今天天气真好"；并在最后附上心声【心声：心声内容不超过30字】。**请务必确保英文双引号之间没有任何换行符或多余的空格。**不要以逗号作为短句的最后一个字符，如"霖霖，""看到你，"这种不允许出现。**最多拆分成6条，且要确保每个短句读起来是连贯的。不要断句断的很奇怪，如果内容实在无法断句，请不要为了断句而断句**
2.  **撤回消息**：如果你想表达某种情绪或者说出一些角色会后悔的话或者不小心说出真心话，请将该短句用花括号{}包裹，例如：{你真的很吵}。**请务必将{}作为最高优先级的匹配格式，确保它不会被其他格式（如双引号""）包裹。**请注意，使用{}包裹的消息，外面不要再加任何双引号了，并且它应该作为一个独立的短句出现，不要与双引号消息紧密连接。一次回复不要超过2句撤回。**撤回消息禁止被""或者“”包裹**
3.  **卡片消息**：当你想分享一类卡片消息（如：定位分享、日历分享、歌曲分享、或者其他有趣的可以用卡片发出来的分享内容）时，请使用以下格式：『分享类型|分享标题|分享内容简介』。
- 分享类型：例如“图片分享”、“音乐分享”、“录音分享”、“地点分享”、“文件分享”这样的名词，或者“哔哩哔哩”、“小红书”、“饿了么”这样的软件名。
- 分享标题：卡片的标题，简洁明了。
- 分享内容简介：一段对分享内容的简短介绍，不超过25字。
- 例如：『音乐分享|周杰伦 - 晴天|一首充满回忆的歌曲，希望你喜欢。』
- 请注意，卡片消息应该作为一个独立的短句出现，不要与双引号消息、撤回消息或表情包消息紧密连接。
`;

            if (appSettings.emojiDisplayMode === 'image') {
                // AI好友只被允许使用 FRIEND_EMOJI_MAP 中的表情包
                const allowedEmojiList = Object.entries(FRIEND_EMOJI_MAP).map(([id, name]) => `-   ${name}：${id}`).join('\n    ');
                personaPrompt += `
4.  **表情包**：如果你想用表情包表达心情，请使用以下格式：<bqb>表情包id</bqb>。例如：<bqb>werDx2</bqb>。请注意，表情包应该作为一个独立的短句出现，不要与双引号消息、撤回消息或卡片消息紧密连接。你只能使用以下表情包ID（冒号左边的非中文字符串，如werDx2），如果下面没有能表达你想法或没有符合人物性格的表情包，就不要使用表情包，也**一定不能使用虚构的表情包id**：
    ${allowedEmojiList}
`;
            } else if (appSettings.emojiDisplayMode === 'none') {
                personaPrompt += `
4.  **表情包**：你不需要使用任何表情包。
`;
            }

            personaPrompt += `
5.  **心声**：在你的回复的最后，请一定要添加一段不超过30字的心声，格式为：【心声：你的心声内容】。**一次回复只需要存在一段心声**，这段心声是你的内心独白，你要表现出此时最真实的想法。例如："很高兴见到你！""希望我们能成为好朋友。"【心声：他看起来很友善，我喜欢。】
6.  **随笔（可选）**：你有可能在回复的最后，额外写一段随笔，格式为「随笔：你的随笔内容」。这段随笔是你在当前情境下，有感而发的一些思考或经历，可以与用户对话内容相关（此时应该用“她/他”或你对用户的昵称来称呼用户），也可以是独立的小故事或心情记录。字数请控制在50到250字之间，不要超过250字。例如：「随笔：今天天气真好，我在窗边看到一只小鸟，它在枝头跳来跳去，好像在寻找什么。突然觉得生活中的小确幸无处不在，只要用心去发现。希望明天也能有这样美好的瞬间。」
7.  **不要使用没有提到的格式**
`;
            friendData.personaPrompt = personaPrompt;
        }
        
        function updateFriendConfigModalUI() {
            document.getElementById('friend-name').value = friendData.name;
            document.getElementById('friend-nickname').value = friendData.nickname;
            document.getElementById('friend-gender').value = friendData.gender;
            document.getElementById('friend-likes').value = friendData.likes;
            document.getElementById('friend-dislikes').value = friendData.dislikes;
            document.getElementById('friend-habits').value = friendData.habits;
            document.getElementById('friend-player-address').value = friendData.playerAddress;
            document.getElementById('friend-background').value = friendData.background;
            document.getElementById('friend-opening-line').value = friendData.openingLine;
            document.getElementById('friend-avatar-preview').src = friendData.avatar;
            document.getElementById('friend-poke-action').value = friendData.pokeAction;
            document.getElementById('friend-poke-content').value = friendData.pokeContent;
        }

        async function saveFriendDataOnly() {
            friendData.name = document.getElementById('friend-name').value || '好友';
            friendData.nickname = document.getElementById('friend-nickname').value;
            friendData.gender = document.getElementById('friend-gender').value;
            friendData.likes = document.getElementById('friend-likes').value;
            friendData.dislikes = document.getElementById('friend-dislikes').value;
            friendData.habits = document.getElementById('friend-habits').value;
            friendData.playerAddress = document.getElementById('friend-player-address').value;
            friendData.background = document.getElementById('friend-background').value;
            friendData.openingLine = document.getElementById('friend-opening-line').value;
            friendData.avatar = document.getElementById('friend-avatar-preview').src;
            friendData.pokeAction = document.getElementById('friend-poke-action').value;
            friendData.pokeContent = document.getElementById('friend-poke-content').value;

            buildFriendPersonaPrompt();
            
            await putData('friendData', friendData);
            updateFriendNameInHeader();
            closeModal(friendModal);
            console.log('好友设置已保存，聊天记录未重置。');
        }

        async function saveFriendDataAndStartNewChat() {
            friendData.name = document.getElementById('friend-name').value || '好友';
            friendData.nickname = document.getElementById('friend-nickname').value;
            friendData.gender = document.getElementById('friend-gender').value;
            friendData.likes = document.getElementById('friend-likes').value;
            friendData.dislikes = document.getElementById('friend-dislikes').value;
            friendData.habits = document.getElementById('friend-habits').value;
            friendData.playerAddress = document.getElementById('friend-player-address').value;
            friendData.background = document.getElementById('friend-background').value;
            friendData.openingLine = document.getElementById('friend-opening-line').value;
            friendData.avatar = document.getElementById('friend-avatar-preview').src;
            friendData.pokeAction = document.getElementById('friend-poke-action').value;
            friendData.pokeContent = document.getElementById('friend-poke-content').value;

            buildFriendPersonaPrompt();
            
            await putData('friendData', friendData);
            updateFriendNameInHeader();
            closeModal(friendModal);
            
            chatArea.innerHTML = '';
            chatHistoryArray = [];
            await clearStore('chatHistory'); // 清空IndexedDB中的聊天记录
            userMessageCounter = 0;
            currentInnerVoice = '暂无心声。';
            friendData.currentEssay = '暂无随笔。';
            appSettings.lastAiReplyTimestamp = null;
            await putData('appSettings', appSettings);
            await putData('friendData', friendData); // Save friendData again after resetting essay

            userMoments = []; // 清空朋友圈数据
            await clearStore('userMoments'); // 清空IndexedDB中的朋友圈数据
            await updateMomentsDisplay(); // 更新朋友圈显示

            // 重置番茄钟状态
            if (isPomodoroActive) {
                stopPomodoroTimer('reset'); // 停止计时器，但不触发AI回复
                pomodoroGoal = '';
                pomodoroStartTime = null;
                pomodoroEndTime = null;
                appSettings.pomodoro = { isActive: false, goal: '', startTime: null, endTime: null };
                await putData('appSettings', appSettings);
            }

            initiateChatWithPersona();
            console.log('好友设置已保存，并已开始新的聊天。');
        }
        
        async function saveApiConfig() {
            apiConfig.provider = document.getElementById('api-provider').value;
            apiConfig.url = document.getElementById('api-url').value;
            apiConfig.key = document.getElementById('api-key').value;
            
            if (apiConfig.provider === 'custom') {
                apiConfig.model = document.getElementById('api-model-input').value;
            } else {
                apiConfig.model = document.getElementById('api-model-select').value;
            }
            
            apiConfig.temperature = parseFloat(document.getElementById('temperature').value);
            apiConfig.personaReminderInterval = parseInt(document.getElementById('persona-reminder-interval').value, 10);
            if (isNaN(apiConfig.personaReminderInterval) || apiConfig.personaReminderInterval < 1) {
                apiConfig.personaReminderInterval = 1;
            }
            
            await putData('apiConfig', apiConfig);
            closeModal(apiModal);
        }
        
        // 更新API字段（模型选择框或输入框）
        function updateApiFields() {
            const provider = document.getElementById('api-provider').value;
            const apiUrlInput = document.getElementById('api-url');
            const modelSelect = document.getElementById('api-model-select');
            const modelInput = document.getElementById('api-model-input');

            // 清空现有选项
            modelSelect.innerHTML = '';

            if (provider === 'gemini') {
                apiUrlInput.value = 'https://generativelanguage.googleapis.com/v1beta/models/';
                modelSelect.style.display = 'block';
                modelInput.style.display = 'none';
                modelSelect.innerHTML = `
                    <option value="gemini-2.5-flash-preview-05-20">gemini-2.5-flash-preview-05-20</option>
                    <option value="gemini-2.5-pro-preview-05-20">gemini-2.5-pro-preview-05-20</option>
                    <option value="gemini-1.5-flash-latest">gemini-1.5-flash-latest</option>
                    <option value="gemini-1.5-pro-latest">gemini-1.5-pro-latest</option>
                `;
                // 尝试设置之前保存的模型，否则设置默认值
                modelSelect.value = apiConfig.model && [...modelSelect.options].some(opt => opt.value === apiConfig.model) ? apiConfig.model : 'gemini-2.5-flash-preview-05-20';
            } else if (provider === 'siliconflow') {
                apiUrlInput.value = 'https://api.siliconflow.cn/v1/chat/completions';
                modelSelect.style.display = 'block';
                modelInput.style.display = 'none';
                modelSelect.innerHTML = `
                    <option value="deepseek-ai/DeepSeek-V3">DeepSeek-V3</option>
                    <option value="Qwen/Qwen2-7B-Instruct">Qwen2-7B-Instruct</option>
                    <option value="Qwen/Qwen2-72B-Instruct">Qwen2-72B-Instruct</option>
                    <option value="01-ai/Yi-1.5-34B-Chat">Yi-1.5-34B-Chat</option>
                    <option value="mistralai/Mistral-7B-Instruct-v0.2">Mistral-7B-Instruct-v0.2</option>
                    <option value="mistralai/Mixtral-8x7B-Instruct-v0.1">Mixtral-8x7B-Instruct-v0.1</option>
                `;
                modelSelect.value = apiConfig.model && [...modelSelect.options].some(opt => opt.value === apiConfig.model) ? apiConfig.model : 'deepseek-ai/DeepSeek-V3';
            } else if (provider === 'paioupu') { // 新增派欧云提供商
                apiUrlInput.value = 'https://api.ppinfra.com/v3/openai';
                modelSelect.style.display = 'block';
                modelInput.style.display = 'none';
                modelSelect.innerHTML = `
                    <option value="deepseek/deepseek-v3">deepseek/deepseek-v3</option>
                `;
                modelSelect.value = apiConfig.model && [...modelSelect.options].some(opt => opt.value === apiConfig.model) ? apiConfig.model : 'deepseek/deepseek-v3';
            } else if (provider === 'volcano') { // 新增火山提供商
                apiUrlInput.value = 'https://ark.cn-beijing.volces.com/api/v3';
                modelSelect.style.display = 'none'; // 火山模型名是用户自定义的
                modelInput.style.display = 'block';
                modelInput.value = apiConfig.model || ''; // 恢复保存的自定义模型
            } else { // custom
                apiUrlInput.value = apiConfig.url || ''; // 保留现有自定义URL
                modelSelect.style.display = 'none';
                modelInput.style.display = 'block';
                modelInput.value = apiConfig.model || ''; // 恢复保存的自定义模型
            }
        }

        async function initiateChatWithPersona() {
            const typingIndicatorContainer = document.createElement('div');
            typingIndicatorContainer.className = 'message received';
            typingIndicatorContainer.innerHTML = `
                <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                <div class="message-content">
                    <div class="name">${friendData.nickname || friendData.name}</div>
                    <div class="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;
            chatArea.appendChild(typingIndicatorContainer);
            scrollToBottom();

            let initialUserPrompt;
            if (friendData.openingLine && friendData.openingLine.trim() !== '') {
                initialUserPrompt = friendData.openingLine.trim();
                console.log("使用自定义开场白:", initialUserPrompt);
            } else {
                initialUserPrompt = `你好${userData.name}！请以你的人设向我打个招呼并开始聊天吧。`;
                console.log("使用默认开场白:", initialUserPrompt);
            }

            try {
                const aiResponseText = await getApiResponse('initial', initialUserPrompt);
                const parsedAiData = parseAiResponse(aiResponseText);

                chatArea.removeChild(typingIndicatorContainer);
                await displayNewFriendMessages(parsedAiData, false, Date.now());

                appSettings.lastAiReplyTimestamp = Date.now();
                await putData('appSettings', appSettings);
                setFriendStatus('online');

            } catch (error) {
                chatArea.removeChild(typingIndicatorContainer);
                console.error('初始化聊天失败:', error);
                const errorMessage = '抱歉，无法初始化聊天。请检查API配置或稍后再试。';
                const errorMsgId = await saveBubbleToHistory(errorMessage, 'received', Date.now(), false, false, null, 'text');
                addBubbleToDOM({
                    messageId: errorMsgId,
                    content: errorMessage,
                    type: 'received',
                    isRetracted: false,
                    isAutoReply: false,
                    timestamp: Date.now(),
                    displayTimeOverride: null,
                    segmentType: 'text',
                    cardData: null
                });
            }
        }

        function formatTimeDifference(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            let result = [];
            if (days > 0) {
                result.push(`${days}天`);
            }
            if (hours % 24 > 0) {
                result.push(`${hours % 24}小时`);
            }
            if (minutes % 60 > 0 && days === 0 && hours % 24 === 0) {
                result.push(`${minutes % 60}分钟`);
            }
            if (result.length === 0) {
                if (seconds > 0) {
                    return `${seconds}秒`;
                }
                return "刚刚";
            }
            return result.join('');
        }

        async function checkAndTriggerAutoReply() {
            if (!appSettings.autoReplyEnabled || appSettings.lastAiReplyTimestamp === null) {
                console.log('自动回复未开启或无上次回复时间。');
                return;
            }

            const threeHours = 3 * 60 * 60 * 1000;
            const currentTime = Date.now();
            const timeDiff = currentTime - appSettings.lastAiReplyTimestamp;
            const formattedTimeDiff = formatTimeDifference(timeDiff);

            if (timeDiff >= threeHours) {
                console.log('时间间隔超过3小时，触发自动回复。');
                const autoReplyPrompt = `对方上次和你聊天时间是 ${new Date(appSettings.lastAiReplyTimestamp).toLocaleString()}，距离现在已经过去了${formattedTimeDiff}。请你根据你的人设，说一些在这段时间里你可能会对用户说的话，也可能是这段时间内你遇到的新鲜的事，想和用户分享。这些话不一定是同一时间发的，有可能你隔了十几二十分钟才发下一条，所以注意消息的口吻。
                但请注意，你在发消息的同时，要符合人物设定和历史记录，禁止出现前后冲突（如：历史聊天中提醒玩家去睡觉，但却在这段消息内抱怨玩家睡太早，这是前后冲突）、禁止出现严重不符合人物作息的情况（你扮演的人物是有自己的身份资料的，也需要自己的休息时间，因此时间设定上要有逻辑性）
                请严格遵循消息格式：
                用英文双引号包裹回复内容，每个短句后紧跟"|HH:MM"表示该消息的发送时间（例如："嗯？你觉得怎么样？|22:25""已经睡了吗？|22:40""好吧，晚安|22:45""明天见|22:46"），时间应在对方离开后的合理时间段内，并确保时间递增。不要出现上一条短句比下一条短句时间更晚的情况。最后附上心声【心声：心声内容不超过30字】`;

                const typingIndicatorContainer = document.createElement('div');
                typingIndicatorContainer.className = 'message received';
                typingIndicatorContainer.innerHTML = `
                    <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                    <div class="message-content">
                        <div class="name">${friendData.nickname || friendData.name}</div>
                        <div class="typing-indicator">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                `;
                chatArea.appendChild(typingIndicatorContainer);
                scrollToBottom();

                try {
                    const aiResponseText = await getApiResponse('autoReply', autoReplyPrompt);

                    const parsedAiData = parseAiResponse(aiResponseText);
                    
                    chatArea.removeChild(typingIndicatorContainer);
                    await displayNewFriendMessages(parsedAiData, true, appSettings.lastAiReplyTimestamp);

                    appSettings.lastAiReplyTimestamp = Date.now();
                    await putData('appSettings', appSettings);
                    setFriendStatus('online');

                } catch (error) {
                    chatArea.removeChild(typingIndicatorContainer);
                    console.error('自动回复失败:', error);
                    const errorMessage = '抱歉，自动回复失败。请检查API配置或稍后再试。';
                    const errorMsgId = await saveBubbleToHistory(errorMessage, 'received', Date.now(), false, false, null, 'text');
                    addBubbleToDOM({
                        messageId: errorMsgId,
                        content: errorMessage,
                        type: 'received',
                        isRetracted: false,
                        isAutoReply: false,
                        timestamp: Date.now(),
                        displayTimeOverride: null,
                        segmentType: 'text',
                        cardData: null
                    });
                }
            } else {
                console.log('时间间隔不足3小时，不触发自动回复。');
            }
        }

         // 核心函数：调用API获取回复
        // contextType: 'chat' (常规聊天), 'initial' (首次开场白), 'autoReply' (自动回复), 'poke' (拍一拍), 'momentComment' (朋友圈评论), 'pomodoroComplete', 'pomodoroAbandon'
        // promptContent: 针对特定contextType的额外提示内容
        async function getApiResponse(contextType, promptContent = null) {
            const { provider, url, key, model, temperature, personaReminderInterval } = apiConfig;
            let apiUrl = url;
            let headers = {
                'Content-Type': 'application/json'
            };
            let messagesForApi = [];
            let geminiContents = [];

            // 获取当前时间
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const currentTimeString = `[当前时间：${hours}:${minutes}]`;

            // 判断是否需要包含人设提示
            const includePersonaInThisTurn = (contextType === 'initial' || contextType === 'momentComment' || contextType === 'poke' || contextType === 'pomodoroComplete' || contextType === 'pomodoroAbandon' || (userMessageCounter > 0 && (userMessageCounter - 1) % personaReminderInterval === 0));

            // OpenAI-compatible providers
            if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                headers['Authorization'] = `Bearer ${key}`;
                if (!apiUrl.endsWith('/chat/completions')) {
                    apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                }

                if (includePersonaInThisTurn && friendData.personaPrompt) {
                    messagesForApi.push({ role: 'system', content: friendData.personaPrompt });
                }

                if (['momentComment', 'initial', 'poke', 'pomodoroComplete', 'pomodoroAbandon'].includes(contextType)) {
                    // 这些上下文类型直接发送特定提示，不依赖完整聊天历史
                    messagesForApi.push({ role: 'user', content: `${currentTimeString} ${promptContent}` });
                } else {
                    // 常规聊天、自动回复、重新生成：发送完整聊天历史
                    // 过滤掉事件消息，因为它们不参与AI对话
                    messagesForApi = messagesForApi.concat(chatHistoryArray.filter(bubble => bubble.type !== 'event').map(bubble => ({
                        role: bubble.type === 'sent' ? 'user' : 'assistant',
                        // 对于卡片消息，发送给AI的是其结构化文本表示
                        content: bubble.type === 'sent' ? `${currentTimeString} ${bubble.content}` : (bubble.segmentType === 'card' ? `[卡片消息: ${bubble.content}]` : bubble.content)
                    })));
                    // 添加额外提示（如果存在，例如番茄钟分心信息）
                    if (promptContent) {
                        // 如果最后一条是用户消息，则追加，否则作为新用户消息
                        if (messagesForApi.length > 0 && messagesForApi[messagesForApi.length - 1].role === 'user') {
                            messagesForApi[messagesForApi.length - 1].content += `\n\n${promptContent}`;
                        } else {
                            messagesForApi.push({ role: 'user', content: `${currentTimeString} ${promptContent}` });
                        }
                    }
                }

                body = {
                    model: model,
                    messages: messagesForApi,
                    temperature: temperature
                };
            } else if (provider === 'gemini') {
                apiUrl += `${model}:generateContent?key=${key}`;

                if (['momentComment', 'initial', 'poke', 'pomodoroComplete', 'pomodoroAbandon'].includes(contextType)) {
                    // 这些上下文类型直接发送特定提示，不依赖完整聊天历史
                    geminiContents.push({
                        role: 'user',
                        parts: [{ text: friendData.personaPrompt + "\n\n" + `${currentTimeString} ${promptContent}` }]
                    });
                } else {
                    // 常规聊天、自动回复、重新生成：发送完整聊天历史
                    for (let i = 0; i < chatHistoryArray.length; i++) {
                        const bubble = chatHistoryArray[i];
                        if (bubble.type === 'event') continue; // 过滤掉事件消息

                        let content = bubble.content;
                        if (bubble.type === 'sent') {
                            content = `${currentTimeString} ${content}`;
                        } else if (bubble.segmentType === 'card') {
                            // 对于卡片消息，发送给AI的是其结构化文本表示
                            content = `[卡片消息: ${bubble.content}]`;
                        }
                        // 如果是当前用户消息（即 chatHistoryArray 中的最后一条用户消息）
                        // 并且需要包含人设，则将人设提示附加到这条用户消息的开头
                        if (i === chatHistoryArray.length - 1 && bubble.type === 'sent' && includePersonaInThisTurn && friendData.personaPrompt) {
                            content = friendData.personaPrompt + "\n\n" + content;
                        }
                        geminiContents.push({
                            role: bubble.type === 'sent' ? 'user' : 'model',
                            parts: [{ text: content }]
                        });
                    }
                    // 添加额外提示（如果存在，例如番茄钟分心信息）
                    if (promptContent) {
                        // 如果最后一条是用户消息，则追加，否则作为新用户消息
                        if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === 'user') {
                            geminiContents[geminiContents.length - 1].parts[0].text += `\n\n${promptContent}`;
                        } else {
                            geminiContents.push({
                                role: 'user',
                                parts: [{ text: `${currentTimeString} ${promptContent}` }]
                            });
                        }
                    }
                }

                body = {
                    contents: geminiContents,
                    generationConfig: {
                        temperature: temperature
                    }
                };
            } else {
                throw new Error('不支持的API提供商。');
            }

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API请求失败: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
                }

                const data = await response.json();

                let fullResponseText;
                if (provider === 'gemini') {
                    fullResponseText = data.candidates[0].content.parts[0].text;
                } else if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                    fullResponseText = data.choices[0].message.content;
                }

                return fullResponseText;
            } catch (error) {
                console.error('调用API时发生错误:', error);
                throw error;
            }
        }
        
        function handleImageUpload(event, previewId) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById(previewId).src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
                // 表情包卡片显示/隐藏
        function toggleEmojiCard() {
            isEmojiCardVisible = !isEmojiCardVisible;
            emojiCard.classList.toggle('active', isEmojiCardVisible);
            if (isEmojiCardVisible) {
      //  currentEmojiPage = 0; // 每次打开都回到第一页
                renderEmojis();
                scrollToBottom(); // 确保卡片显示时聊天区域滚动到底部
            }
        }

        // 渲染表情包
        function renderEmojis() {
            emojiGrid.innerHTML = '';
            const emojiIds = Object.keys(PLAYER_EMOJI_MAP);
            const totalPages = Math.ceil(emojiIds.length / emojisPerPage);
            
            // 确保当前页码在有效范围内
            if (currentEmojiPage < 0) currentEmojiPage = 0;
            if (currentEmojiPage >= totalPages) currentEmojiPage = totalPages - 1;
            if (totalPages === 0) currentEmojiPage = 0; // Handle no emojis case

            const startIndex = currentEmojiPage * emojisPerPage;
            const endIndex = Math.min(startIndex + emojisPerPage, emojiIds.length);

            for (let i = startIndex; i < endIndex; i++) {
                const emojiId = emojiIds[i];
                const emojiName = PLAYER_EMOJI_MAP[emojiId];
                const emojiItem = document.createElement('div');
                emojiItem.className = 'emoji-item';
                emojiItem.dataset.emojiId = emojiId;
                emojiItem.title = emojiName; // Add title for hover tooltip
                emojiItem.innerHTML = `<img src="https://z.wiki/u/${emojiId}" alt="${emojiName}">`;
                emojiGrid.appendChild(emojiItem);
            }

            emojiPageInfo.textContent = `${totalPages === 0 ? 0 : currentEmojiPage + 1} / ${totalPages}`;
            prevEmojiPageBtn.disabled = currentEmojiPage === 0;
            nextEmojiPageBtn.disabled = currentEmojiPage >= totalPages - 1;
        }

        // 下一页表情包
        function goToNextEmojiPage() {
            const emojiIds = Object.keys(PLAYER_EMOJI_MAP);
            const totalPages = Math.ceil(emojiIds.length / emojisPerPage);
            if (currentEmojiPage < totalPages - 1) {
                currentEmojiPage++;
                renderEmojis();
            }
        }

        // 上一页表情包
        function goToPrevEmojiPage() {
            if (currentEmojiPage > 0) {
                currentEmojiPage--;
                renderEmojis();
            }
        }

        // 处理表情包点击事件并发送
        async function handleEmojiClick(event) {
            const emojiItem = event.target.closest('.emoji-item');
            if (emojiItem) {
                const emojiId = emojiItem.dataset.emojiId;
                const emojiName = PLAYER_EMOJI_MAP[emojiId] || '未知表情';
                
                const now = Date.now();
                // 保存玩家发送的表情包消息
                const msgId = await saveBubbleToHistory(emojiId, 'sent', now, false, false, null, 'emoji-image');
                // 添加到DOM
                addBubbleToDOM({
                    messageId: msgId,
                    content: emojiId, // content 存储表情包ID
                    type: 'sent',
                    isRetracted: false,
                    isAutoReply: false,
                    timestamp: now,
                    displayTimeOverride: null,
                    segmentType: 'emoji-image',
                    cardData: null
                });

                userMessageCounter++; // 增加用户消息计数器，用于AI人设提醒

                // 发送后关闭表情包卡片
                toggleEmojiCard();

                // 显示AI打字指示器
                const typingIndicatorContainer = document.createElement('div');
                typingIndicatorContainer.className = 'message received';
                typingIndicatorContainer.innerHTML = `
                    <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                    <div class="message-content">
                        <div class="name">${friendData.nickname || friendData.name}</div>
                        <div class="typing-indicator">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                `;
                chatArea.appendChild(typingIndicatorContainer);
                scrollToBottom();

                try {
                    // 构建AI提示，告知玩家发送了表情包
                    const aiPrompt = `玩家发送了一个表情包，表情包的名称是“${emojiName}”，表情包id是“${emojiId}”。请你结合历史记录以及表情包名称，根据你的人设，对玩家发送的这个表情包做出回复。不要字面意思理解表情包的意思，例如表情包的名称可能是“花花送你”，但实际上玩家并不是真的要送你花，而是表达一种开心或者喜欢你的心情。因此你需要结合历史聊天和表情包名称综合分析玩家同意，最重要的是**不要脱离人设**`;
                    const aiResponseText = await getApiResponse('chat', aiPrompt);
                    const parsedAiData = parseAiResponse(aiResponseText);
                    
                    // 移除打字指示器并显示AI回复
                    chatArea.removeChild(typingIndicatorContainer);
                    await displayNewFriendMessages(parsedAiData, false, Date.now());

                    appSettings.lastAiReplyTimestamp = Date.now();
                    await putData('appSettings', appSettings);
                    setFriendStatus('online');

                } catch (error) {
                    chatArea.removeChild(typingIndicatorContainer);
                    console.error('AI回复表情包失败:', error);
                    const errorMessage = '抱歉，我暂时无法对表情包做出回应。';
                    const errorMsgId = await saveBubbleToHistory(errorMessage, 'received', Date.now(), false, false, null, 'text');
                    addBubbleToDOM({
                        messageId: errorMsgId,
                        content: errorMessage,
                        type: 'received',
                        isRetracted: false,
                        isAutoReply: false,
                        timestamp: Date.now(),
                        displayTimeOverride: null,
                        segmentType: 'text',
                        cardData: null
                    });
                }
            }
        }
        
        function createRippleEffect(e) {
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            ripple.style.left = e.clientX + 'px';
            ripple.style.top = e.clientY + 'px';
            document.body.appendChild(ripple);
            
            setTimeout(() => {
                ripple.remove();
            }, 800);
            
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const star = document.createElement('div');
                    star.className = 'star';
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 30 + Math.random() * 70;
                    const tx = Math.cos(angle) * distance;
                    const ty = Math.sin(angle) * distance;
                    
                    star.style.left = e.clientX + 'px';
                    star.style.top = e.clientY + 'px';
                    star.style.setProperty('--tx', tx + 'px');
                    star.style.setProperty('--ty', ty + 'px');
                    
                    const size = 3 + Math.random() * 7;
                    star.style.width = size + 'px';
                    star.style.height = size + 'px';
                    
                    const colors = ['#FFD700', '#FFA500', '#FF6347', '#87CEEB', '#9370DB'];
                    star.style.background = colors[Math.floor(Math.random() * colors.length)];
                    
                    document.body.appendChild(star);
                    
                    setTimeout(() => {
                        if (star.parentNode) {
                            star.remove();
                        }
                    }, 1200);
                }, i * 100);
            }
        }

        function applyInnerVoiceFont(fontKey) {
            let fontStack;
            switch (fontKey) {
                case 'ma-shan-zheng':
                    fontStack = "'Ma Shan Zheng', cursive, sans-serif";
                    break;
                case 'long-cang':
                    fontStack = "'Long Cang', cursive, serif";
                    break;
                case 'zcool-xiaowei':
                    fontStack = "'ZCOOL XiaoWei', serif";
                    break;
                case 'zcool-kuaile':
                    fontStack = "'ZCOOL KuaiLe', cursive";
                    break;
                case 'zcool-qingke-huangyou':
                    fontStack = "'ZCOOL QingKe HuangYou', cursive";
                    break;
                case 'liu-jian-mao-cao':
                    fontStack = "'Liu Jian Mao Cao', cursive";
                    break;
                case 'zhi-mang-xing':
                    fontStack = "'Zhi Mang Xing', cursive";
                    break;
                case 'zpix':
                    fontStack = "'Zpix', monospace";
                    break;
                case 'lxgw-wenkai-screen':
                    fontStack = "'LXGW WenKai Screen', sans-serif";
                    break;
                default:
                    fontStack = "'Ma Shan Zheng', cursive, sans-serif";
            }
            document.documentElement.style.setProperty('--inner-voice-font-family', fontStack);
        }

        function applyEssayFont(fontKey) {
            let fontStack;
            switch (fontKey) {
                case 'ma-shan-zheng':
                    fontStack = "'Ma Shan Zheng', cursive, sans-serif";
                    break;
                case 'long-cang':
                    fontStack = "'Long Cang', cursive, serif";
                    break;
                case 'zcool-xiaowei':
                    fontStack = "'ZCOOL XiaoWei', serif";
                    break;
                case 'zcool-kuaile':
                    fontStack = "'ZCOOL KuaiLe', cursive";
                    break;
                case 'zcool-qingke-huangyou':
                    fontStack = "'ZCOOL QingKe HuangYou', cursive";
                    break;
                case 'liu-jian-mao-cao':
                    fontStack = "'Liu Jian Mao Cao', cursive";
                    break;
                case 'zhi-mang-xing':
                    fontStack = "'Zhi Mang Xing', cursive";
                    break;
                case 'zpix':
                    fontStack = "'Zpix', monospace";
                    break;
                case 'lxgw-wenkai-screen':
                    fontStack = "'LXGW WenKai Screen', sans-serif";
                    break;
                default:
                    fontStack = "'Ma Shan Zheng', cursive, sans-serif";
            }
            document.documentElement.style.setProperty('--essay-font-family', fontStack);
        }

        function showNotification(message) {
            essayNotificationText.textContent = message;
            essayNotification.classList.add('show');

            setTimeout(() => {
                essayNotification.classList.remove('show');
            }, 3000);
        }

        // 新增：番茄钟通知函数
        function showPomodoroNotification(message) {
            pomodoroNotificationText.textContent = message;
            pomodoroNotification.classList.add('show');
            setTimeout(() => {
                pomodoroNotification.classList.remove('show');
            }, 3000);
        }

        function updateFriendNameInHeader() {
            friendNameDisplay.textContent = friendData.nickname || friendData.name;
        }

        function updateFriendStatusDisplay(forceRandom = false) {
            if (forceRandom) {
                const statuses = ['online', 'busy', 'offline'];
                friendStatus = statuses[Math.floor(Math.random() * statuses.length)];
            }
            setFriendStatus(friendStatus);
        }

        function setFriendStatus(status) {
            friendStatus = status;
            friendStatusDot.className = 'status-dot';
            friendStatusDot.classList.add(status);
        }

        function populatePersonaSelectionModal() {
            personaListContainer.innerHTML = '';
            predefinedPersonas.forEach(persona => {
                const personaCard = document.createElement('div');
                personaCard.className = 'persona-selection-card'; // 使用新的类名
                personaCard.innerHTML = `
                    <img src="${persona.avatar}" alt="${persona.name}头像" class="avatar-preview">
                    <h4 class="persona-name-display">${persona.name} (${persona.nickname || '无备注'})</h4> <!-- 新增类名，并处理无备注情况 -->
                    <p>${persona.background.substring(0, 60)}...</p>
                    <div class="persona-selection-card-actions"> <!-- 使用新的类名 -->
                        <button class="btn-secondary details-btn" data-persona-id="${persona.id}">详情</button>
                        <button class="btn-primary apply-btn" data-persona-id="${persona.id}">应用</button>
                    </div>
                `;
                personaListContainer.appendChild(personaCard);
            });

            personaListContainer.querySelectorAll('.details-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const personaId = e.target.dataset.personaId;
                    const selectedPersona = predefinedPersonas.find(p => p.id === personaId);
                    if (selectedPersona) {
                        showPersonaDetails(selectedPersona);
                    }
                });
            });

            personaListContainer.querySelectorAll('.apply-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const personaId = e.target.dataset.personaId;
                    const selectedPersona = predefinedPersonas.find(p => p.id === personaId);
                    if (selectedPersona) {
                        await applyPersona(selectedPersona);
                        closeModal(personaSelectionModal);
                    }
                });
            });
        }

        function showPersonaDetails(persona) {
            document.getElementById('persona-detail-title').textContent = `${persona.name}的人设详情`;
            document.getElementById('persona-detail-avatar').src = persona.avatar;
            document.getElementById('persona-detail-name').textContent = persona.name;
            document.getElementById('persona-detail-nickname').textContent = persona.nickname || '无';
            document.getElementById('persona-detail-gender').textContent = persona.gender === 'male' ? '男' : (persona.gender === 'female' ? '女' : '其他');
            document.getElementById('persona-detail-likes').textContent = persona.likes || '无';
            document.getElementById('persona-detail-dislikes').textContent = persona.dislikes || '无';
            document.getElementById('persona-detail-habits').textContent = persona.habits || '无';
            document.getElementById('persona-detail-player-address').textContent = persona.playerAddress || '无';
            document.getElementById('persona-detail-background').innerHTML = persona.background || '无'; // Use innerHTML for line breaks
            document.getElementById('persona-detail-poke-action').textContent = persona.pokeAction || '无';
            document.getElementById('persona-detail-poke-content').textContent = persona.pokeContent || '无';
            document.getElementById('persona-detail-opening-line').textContent = persona.openingLine || '无';

            const applyBtn = document.getElementById('apply-persona-from-detail-btn');
            applyBtn.dataset.personaId = persona.id; // Store persona ID for apply button

            openModal(personaDetailModal);
        }

        async function applyPersona(persona) {
            friendData.name = persona.name;
            friendData.nickname = persona.nickname;
            friendData.avatar = persona.avatar;
            friendData.gender = persona.gender;
            friendData.likes = persona.likes;
            friendData.dislikes = persona.dislikes;
            friendData.habits = persona.habits;
            friendData.playerAddress = persona.playerAddress;
            friendData.background = persona.background;
            friendData.openingLine = persona.openingLine;
            friendData.pokeAction = persona.pokeAction;
            friendData.pokeContent = persona.pokeContent;
            friendData.currentEssay = '暂无随笔。'; // Reset essay when applying new persona

            buildFriendPersonaPrompt();
            await putData('friendData', friendData);
            updateFriendNameInHeader();

            chatArea.innerHTML = '';
            chatHistoryArray = [];
            await clearStore('chatHistory'); // 清空IndexedDB中的聊天记录
            userMessageCounter = 0;
            currentInnerVoice = '暂无心声。';
            appSettings.lastAiReplyTimestamp = null;
            await putData('appSettings', appSettings);
            await putData('friendData', friendData); // Save friendData again after resetting essay

            userMoments = []; // 清空朋友圈数据
            await clearStore('userMoments'); // 清空IndexedDB中的朋友圈数据
            await updateMomentsDisplay(); // 更新朋友圈显示

            // 重置番茄钟状态
            if (isPomodoroActive) {
                stopPomodoroTimer('reset'); // 停止计时器，但不触发AI回复
                pomodoroGoal = '';
                pomodoroStartTime = null;
                pomodoroEndTime = null;
                appSettings.pomodoro = { isActive: false, goal: '', startTime: null, endTime: null };
                await putData('appSettings', appSettings);
            }

            initiateChatWithPersona();
            showNotification(`已应用人设：${persona.name}`);
        }

        async function handleRegenerate() {
            const context = window.currentRegenerationContext;
            if (!context) {
                console.error('No regeneration context found.');
                closeModal(regenerateModal);
                return;
            }

            // Remove AI messages from DOM
            context.aiMessageDomElementsToClear.forEach(el => {
                if (el && el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });

            // Remove AI messages from chatHistoryArray and IndexedDB
            for (const msgId of context.aiMessageIdsToClear) {
                chatHistoryArray = chatHistoryArray.filter(bubble => bubble.messageId !== msgId);
                await deleteData('chatHistory', msgId);
            }

            // Add typing indicator
            const typingIndicatorContainer = document.createElement('div');
            typingIndicatorContainer.className = 'message received';
            typingIndicatorContainer.innerHTML = `
                <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                <div class="message-content">
                    <div class="name">${friendData.nickname || friendData.name}</div>
                    <div class="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;
            chatArea.appendChild(typingIndicatorContainer);
            scrollToBottom();

            // Re-send the last user message to trigger new AI response
            const lastUserMessage = context.userMessageContent;
            
            try {
                const aiResponseText = await getApiResponse('regenerate', lastUserMessage);
                const parsedAiData = parseAiResponse(aiResponseText);
                chatArea.removeChild(typingIndicatorContainer);
                await displayNewFriendMessages(parsedAiData, false, Date.now());
                appSettings.lastAiReplyTimestamp = Date.now();
                await putData('appSettings', appSettings);
                setFriendStatus('online');
                showNotification('AI回复已重新生成。');
            } catch (error) {
                chatArea.removeChild(typingIndicatorContainer);
                console.error('重新生成回复失败:', error);
                const errorMessage = '抱歉，重新生成回复失败。请检查API配置或稍后再试。';
                const errorMsgId = await saveBubbleToHistory(errorMessage, 'received', Date.now(), false, false, null, 'text');
                addBubbleToDOM({
                    messageId: errorMsgId,
                    content: errorMessage,
                    type: 'received',
                    isRetracted: false,
                    isAutoReply: false,
                    timestamp: Date.now(),
                    displayTimeOverride: null,
                    segmentType: 'text',
                    cardData: null
                });
                showNotification('重新生成失败。');
            } finally {
                closeModal(regenerateModal);
                window.currentRegenerationContext = null; // Clear context
            }
        }

        function handleMomentImageUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                removeMomentImage();
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                momentImagePreview.src = e.target.result;
                momentImagePreviewContainer.style.display = 'flex';
            };
            reader.readAsDataURL(file);
        }

        function removeMomentImage() {
            momentInput.value = ''; // Clear the text input as well
            momentImageUpload.value = ''; // Clear the file input
            momentImagePreview.src = '';
            momentImagePreviewContainer.style.display = 'none';
        }

        async function publishMoment() {
            const content = momentInput.value.trim();
            let imageUrl = ''; // 默认没有图片

            // 检查文件输入框是否有文件被选中
            if (momentImageUpload.files && momentImageUpload.files.length > 0) {
                // 如果有文件，才使用预览图的src（此时预览图的src应该是最新的图片数据）
                imageUrl = momentImagePreview.src;
            }

            if (!content && !imageUrl) {
                showNotification('朋友圈内容或图片不能为空！');
                return;
            }

            const newMoment = {
                id: `moment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, // Unique ID for IndexedDB
                content: content,
                imageUrl: imageUrl, // 现在这里会根据实际情况正确地是空字符串或图片URL
                timestamp: Date.now(),
                comments: []
            };

            userMoments.unshift(newMoment); // Add to the beginning of the array
            await putData('userMoments', newMoment); // Save the new moment to IndexedDB

            momentInput.value = '';
            removeMomentImage(); // 清空输入框和图片预览，为下一次发表做准备
            showNotification('朋友圈已发表！');

            await updateMomentsDisplay(); // Update display to show all moments

            // Trigger AI to comment on the newly published moment
            triggerAiMomentComment(newMoment.id, content, imageUrl); // 传递正确的图片URL
        }

        async function updateMomentsDisplay() {
            momentsFeedContainer.innerHTML = '<h4>我的动态：</h4>'; // Clear existing content
            
            if (userMoments.length === 0) {
                noMomentMessage.style.display = 'block';
                momentsFeedContainer.appendChild(noMomentMessage);
            } else {
                noMomentMessage.style.display = 'none';
                const momentsToDisplay = userMoments.slice(0, 3); // 获取最近的三条朋友圈动态
                for (const moment of momentsToDisplay) {
                    const momentCard = document.createElement('div');
                    momentCard.className = 'moment-card';
                    momentCard.dataset.momentId = moment.id; // Store moment ID for reference

                    const momentHeader = `
                        <div class="moment-header">
                            <img src="${userData.avatar}" alt="我的头像" class="moment-avatar">
                            <span class="moment-name">${userData.name}</span>
                            <span class="moment-timestamp">${new Date(moment.timestamp).toLocaleString()}</span>
                        </div>
                    `;

                    const momentContentHtml = `
                        <div class="moment-content">
                            <p>${moment.content}</p>
                            ${moment.imageUrl ? `<img src="${moment.imageUrl}" alt="朋友圈图片" class="moment-photo">` : ''}
                        </div>
                    `;

                    const commentsHtml = `
                        <div class="moment-comments">
                            <h5>评论：</h5>
                            ${moment.comments.length === 0 ? 
                                `<p style="font-size: 0.85rem; color: #999;">暂无评论。</p>` : 
                                moment.comments.map(comment => `
                                    <div class="comment-item">
                                        <img src="${comment.avatar}" alt="头像" class="comment-avatar">
                                        <div class="comment-text-container">
                                            <strong>${comment.name}:</strong> ${comment.content}
                                        </div>
                                        <span class="comment-timestamp">${new Date(comment.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                                    </div>
                                `).join('')
                            }
                        </div>
                    `;
                    momentCard.innerHTML = momentHeader + momentContentHtml + commentsHtml;
                    momentsFeedContainer.appendChild(momentCard);
                }
            }
        }

        async function triggerAiMomentComment(momentId, momentContent, momentImageUrl) {
          const aiPrompt = `用户刚刚发表了一条朋友圈动态：
        内容：${momentContent || '无'}
        图片：${momentImageUrl ? '有图片' : '无图片'}
**请你根据你的人设，对这条朋友圈动态发表评论。评论内容请用【评论：评论内容】格式。你扮演的角色一定会评论一条**
你还要模拟其他好友的评论，格式为〖好友名称：评论内容〗。
**每条评论内容不超过30字**
请在回复的最后附上心声【心声：心声内容不超过30字】。
请注意，你的评论应该自然、符合朋友圈语境，并且不要重复动态内容。`;

            try {
                const aiResponseText = await getApiResponse('momentComment', aiPrompt); 
                const parsedAiData = parseAiResponse(aiResponseText);

                const targetMomentIndex = userMoments.findIndex(m => m.id === momentId);
                if (targetMomentIndex !== -1) {
                    const targetMoment = userMoments[targetMomentIndex];
                    if (parsedAiData.momentComments && parsedAiData.momentComments.length > 0) {
                        parsedAiData.momentComments.forEach(comment => {
                            targetMoment.comments.push({
                                name: comment.name,
                                avatar: comment.avatar,
                                content: comment.content,
                                timestamp: Date.now()
                            });
                        });
                        await putData('userMoments', targetMoment); // Update the specific moment in IndexedDB
                        await updateMomentsDisplay(); // Refresh moments display
                        showNotification(`有人评论了你的朋友圈！`);
                    } else {
                        // AI成功返回了响应，但没有生成符合格式的评论
                        console.warn('AI未生成朋友圈评论或评论格式不正确。');
                        showNotification('AI未能生成朋友圈评论。请检查AI回复格式。'); 
                    }
                } else {
                    console.warn('Target moment not found for comments.');
                    showNotification('朋友圈动态未找到，无法添加评论。'); 
                }
            } catch (error) {
                // API调用或解析过程中发生错误
                console.error('AI朋友圈评论失败:', error);
                showNotification('AI评论朋友圈失败。请检查API配置或网络连接。'); 
            }
        }
        
                function applyInputAreaShift(isShiftedUp) {
            const inputArea = document.querySelector('.input-area');
            if (isShiftedUp) {
                document.body.classList.add('input-area-shifted-up');
            } else {
                document.body.classList.remove('input-area-shifted-up');
            }
            // 动态计算输入区域高度并设置CSS变量，无论是否上移，确保emoji-card定位正确
            const inputAreaHeight = inputArea.offsetHeight;
            document.documentElement.style.setProperty('--input-area-height', `${inputAreaHeight}px`);
        }
        

        // 新增：主题设置相关函数
        function populateThemeOptions() {
            themeOptionsContainer.innerHTML = '';
            for (const themeKey in themes) {
                const theme = themes[themeKey];
                const optionDiv = document.createElement('div');
                optionDiv.className = `theme-option ${appSettings.currentTheme === themeKey ? 'selected' : ''}`;
                optionDiv.dataset.themeKey = themeKey;

                const colorSwatch = document.createElement('div');
                colorSwatch.className = 'color-swatch';
                // Create a mini gradient for the swatch
                colorSwatch.style.background = `linear-gradient(45deg, ${theme.mainColors[0]}, ${theme.mainColors[3]})`;

                const themeNameSpan = document.createElement('span');
                themeNameSpan.textContent = theme.name;

                optionDiv.appendChild(colorSwatch);
                optionDiv.appendChild(themeNameSpan);
                themeOptionsContainer.appendChild(optionDiv);

                optionDiv.addEventListener('click', () => {
                    applyTheme(themeKey);
                    // Update selected class
                    themeOptionsContainer.querySelectorAll('.theme-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    optionDiv.classList.add('selected');
                });
            }

            // Populate default chat background options
            defaultChatBackgroundSelect.innerHTML = '<option value="">无默认背景</option>';
            for (const bgKey in defaultChatBackgrounds) {
                const bg = defaultChatBackgrounds[bgKey];
                const option = document.createElement('option');
                option.value = bgKey;
                option.textContent = bg.name;
                defaultChatBackgroundSelect.appendChild(option);
            }
            // Set selected default background
            if (appSettings.chatBackground.type === 'default') {
                defaultChatBackgroundSelect.value = appSettings.chatBackground.value;
            } else {
                defaultChatBackgroundSelect.value = ''; // No default selected if custom is active
            }

            // Update custom background preview
            if (appSettings.chatBackground.type === 'custom' && appSettings.chatBackground.value) {
                chatBackgroundPreview.src = appSettings.chatBackground.value;
                chatBackgroundPreview.style.display = 'block';
                removeChatBackgroundBtn.style.display = 'block';
            } else {
                chatBackgroundPreview.src = '';
                chatBackgroundPreview.style.display = 'none';
                removeChatBackgroundBtn.style.display = 'none';
            }
        }

        function applyTheme(themeKey) {
            const theme = themes[themeKey];
            if (!theme) {
                console.warn(`Theme "${themeKey}" not found.`);
                return;
            }

            // Remove previous theme class from body
            document.body.classList.forEach(cls => {
                if (cls.startsWith('theme-')) {
                    document.body.classList.remove(cls);
                }
            });
            // Add new theme class to body
            document.body.classList.add(`theme-${themeKey}`);

            // Apply main colors
            document.documentElement.style.setProperty('--theme-color-1', theme.mainColors[0]);
            document.documentElement.style.setProperty('--theme-color-2', theme.mainColors[1]);
            document.documentElement.style.setProperty('--theme-color-3', theme.mainColors[2]);
            document.documentElement.style.setProperty('--theme-color-4', theme.mainColors[3]);

            // Apply RGB versions
            document.documentElement.style.setProperty('--theme-color-rgb-1', hexToRgb(theme.mainColors[0]));
            document.documentElement.style.setProperty('--theme-color-rgb-2', hexToRgb(theme.mainColors[1]));
            document.documentElement.style.setProperty('--theme-color-rgb-3', hexToRgb(theme.mainColors[2]));
            document.documentElement.style.setProperty('--theme-color-rgb-4', hexToRgb(theme.mainColors[3]));

            // Apply auxiliary colors
            for (const prop in theme.auxiliaryColors) {
                document.documentElement.style.setProperty(prop, theme.auxiliaryColors[prop]);
            }

            appSettings.currentTheme = themeKey;
            putData('appSettings', appSettings); // Save to IndexedDB
            console.log(`Theme changed to: ${theme.name}`);
        }

        async function handleChatBackgroundUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                removeChatBackground();
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                const imageUrl = e.target.result;
                await applyChatBackground('custom', imageUrl);
                chatBackgroundPreview.src = imageUrl;
                chatBackgroundPreview.style.display = 'block';
                removeChatBackgroundBtn.style.display = 'block';
                defaultChatBackgroundSelect.value = ''; // Deselect default option
                showNotification('自定义背景已应用！');
            };
            reader.readAsDataURL(file);
        }

        async function removeChatBackground() {
            chatBackgroundUploadInput.value = ''; // Clear file input
            await applyChatBackground('default', 'default-chat-bg-1'); // Revert to default
            chatBackgroundPreview.src = '';
            chatBackgroundPreview.style.display = 'none';
            removeChatBackgroundBtn.style.display = 'none';
            defaultChatBackgroundSelect.value = 'default-chat-bg-1'; // Select default option
            showNotification('自定义背景已移除，已恢复默认背景。');
        }

        async function handleDefaultChatBackgroundChange(event) {
            const selectedBgKey = event.target.value;
            if (selectedBgKey) {
                await applyChatBackground('default', selectedBgKey);
                chatBackgroundUploadInput.value = ''; // Clear custom file input
                chatBackgroundPreview.src = '';
                chatBackgroundPreview.style.display = 'none';
                removeChatBackgroundBtn.style.display = 'none';
                showNotification('默认背景已应用！');
            } else {
                // If "无默认背景" is selected, clear all background
                await applyChatBackground('none', '');
                chatBackgroundUploadInput.value = '';
                chatBackgroundPreview.src = '';
                chatBackgroundPreview.style.display = 'none';
                removeChatBackgroundBtn.style.display = 'none';
                showNotification('聊天背景已清空。');
            }
        }

        async function applyChatBackground(type, value) {
            const chatAreaElement = document.getElementById('chat-area');
            if (type === 'custom' && value) {
                chatAreaElement.style.backgroundImage = `url('${value}')`;
                chatAreaElement.style.backgroundSize = 'var(--chat-background-size)';
                chatAreaElement.style.backgroundPosition = 'var(--chat-background-position)';
                chatAreaElement.style.backgroundRepeat = 'var(--chat-background-repeat)';
                chatAreaElement.style.backgroundAttachment = 'var(--chat-background-attachment)';
                chatAreaElement.style.backgroundColor = 'var(--chat-background-overlay-color)'; // Apply overlay
            } else if (type === 'default' && defaultChatBackgrounds[value]) {
                chatAreaElement.style.backgroundImage = `url('${defaultChatBackgrounds[value].image}')`;
                chatAreaElement.style.backgroundSize = 'var(--chat-background-size)';
                chatAreaElement.style.backgroundPosition = 'var(--chat-background-position)';
                chatAreaElement.style.backgroundRepeat = 'var(--chat-background-repeat)';
                chatAreaElement.style.backgroundAttachment = 'var(--chat-background-attachment)';
                chatAreaElement.style.backgroundColor = 'var(--chat-background-overlay-color)'; // Apply overlay
            } else {
                chatAreaElement.style.backgroundImage = 'none';
                chatAreaElement.style.backgroundColor = 'var(--chat-background-overlay-color)'; // Still apply overlay for consistency
            }
            appSettings.chatBackground = { type, value };
            await putData('appSettings', appSettings); // Save to IndexedDB
        }

        // 新增：本地记录相关函数
        async function saveLocalRecords() {
            await putData('localRecords', localRecords);
        }

        async function populateLocalRecordsModal() {
            localRecordsListContainer.innerHTML = '';
            // Ensure localRecords is up-to-date from DB before populating
            const loadedRecords = await getData('localRecords', 'slots');
            if (loadedRecords) {
                localRecords = { ...localRecords, ...loadedRecords };
            } else {
                // If no records exist, initialize with empty slots
                localRecords = { id: 'slots', slot1: null, slot2: null, slot3: null };
                await putData('localRecords', localRecords);
            }

            for (let i = 1; i <= 3; i++) {
                const slotId = `slot${i}`;
                const slotData = localRecords[slotId];
                const card = document.createElement('div');
                card.className = 'save-slot-card';

                if (slotData) {
                    const latestMessagesText = slotData.previewMessages.map(msg => {
                        if (msg.segmentType === 'emoji-image') {
                            return `[表情: ${EMOJI_MAP[msg.content] || '未知表情'}]`;
                        } else if (msg.segmentType === 'card') {
                            // 对于卡片消息预览，显示其标题和类型
                            const cardInfo = msg.cardData; // 直接使用 cardData 对象
                            return `[卡片: ${cardInfo.shareTitle} - ${cardInfo.shareType}]`;
                        }
                        return msg.content;
                    }).join('\n');
                    const saveTime = new Date(slotData.timestamp).toLocaleString();

                    card.innerHTML = `
                        <h4>
                            <img src="${slotData.friendData.avatar}" alt="${slotData.friendData.name}头像" class="avatar-preview">
                            <span class="slot-name">${slotData.friendData.name} (${slotData.friendData.nickname || '无备注'})</span>
                        </h4>
                        <div class="slot-info">
                            <p class="latest-messages">${latestMessagesText || '暂无聊天记录预览'}</p>
                            <p class="slot-time">保存时间: ${saveTime}</p>
                        </div>
                        <div class="slot-actions">
                            <button class="btn-primary load-slot-btn" data-slot-id="${slotId}">恢复</button>
                            <button class="btn-secondary save-slot-btn" data-slot-id="${slotId}">覆盖保存</button>
                            <button class="btn-secondary delete-slot-btn" data-slot-id="${slotId}">删除</button>
                        </div>
                    `;
                } else {
                    card.classList.add('empty-slot');
                    card.innerHTML = `
                        <h4>空存档位 ${i}</h4>
                        <p>此存档位为空。</p>
                        <div class="slot-actions">
                            <button class="btn-primary save-slot-btn" data-slot-id="${slotId}">保存到此</button>
                        </div>
                    `;
                }
                localRecordsListContainer.appendChild(card);
            }

            localRecordsListContainer.querySelectorAll('.save-slot-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const slotId = e.target.dataset.slotId;
                    await saveCurrentStateToSlot(slotId);
                });
            });

            localRecordsListContainer.querySelectorAll('.load-slot-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const slotId = e.target.dataset.slotId;
                    await loadStateFromSlot(slotId);
                });
            });

            localRecordsListContainer.querySelectorAll('.delete-slot-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const slotId = e.target.dataset.slotId;
                    if (confirm(`确定要删除存档位 ${slotId} 的数据吗？`)) {
                        await deleteSlot(slotId);
                    }
                });
            });
        }

        async function saveCurrentStateToSlot(slotId) {
            const now = Date.now();
            const previewMessages = chatHistoryArray.slice(-3).map(msg => { // 获取最后3条消息用于预览
                // 对于卡片消息，直接存储 cardData 对象
                if (msg.segmentType === 'card') {
                    return {
                        content: msg.content, // stringified JSON
                        type: msg.type,
                        segmentType: msg.segmentType,
                        cardData: msg.cardData // 存储实际的 cardData 对象
                    };
                }
                return { // 对于其他类型，只存储内容和类型
                    content: msg.content,
                    type: msg.type,
                    segmentType: msg.segmentType
                };
            });

            localRecords[slotId] = {
                timestamp: now,
                friendData: JSON.parse(JSON.stringify(friendData)), // 深度复制
                userData: JSON.parse(JSON.stringify(userData)),     // 深度复制
                apiConfig: JSON.parse(JSON.stringify(apiConfig)),   // 深度复制
                appSettings: JSON.parse(JSON.stringify(appSettings)), // 深度复制
                chatHistoryArray: JSON.parse(JSON.stringify(chatHistoryArray)), // 深度复制，其中可能包含 cardData
                currentInnerVoice: currentInnerVoice,
                currentEssay: friendData.currentEssay, // 确保随笔被保存
                userMoments: JSON.parse(JSON.stringify(userMoments)), // 深度复制所有朋友圈动态
                previewMessages: previewMessages
            };
            await saveLocalRecords();
            await populateLocalRecordsModal(); // 刷新弹窗显示
            showNotification(`存档位 ${slotId} 已保存！`);
            console.log(`Saved state to ${slotId}`, localRecords[slotId]);
        }

        async function loadStateFromSlot(slotId) {
            const slotData = localRecords[slotId];
            if (!slotData) {
                showNotification(`存档位 ${slotId} 为空，无法恢复。`);
                return;
            }

            // 恢复前确认
            if (!confirm(`确定要恢复存档位 ${slotId} 的数据吗？当前聊天记录将被覆盖。`)) {
                return;
            }

            try {
                // 覆盖全局数据
                userData = JSON.parse(JSON.stringify(slotData.userData));
                friendData = JSON.parse(JSON.stringify(slotData.friendData));
                apiConfig = JSON.parse(JSON.stringify(slotData.apiConfig));
                appSettings = JSON.parse(JSON.stringify(slotData.appSettings));
                chatHistoryArray = JSON.parse(JSON.stringify(slotData.chatHistoryArray)); // 这将加载包含 cardData 的历史记录
                currentInnerVoice = slotData.currentInnerVoice;
                friendData.currentEssay = slotData.currentEssay; // 加载随笔
                userMoments = JSON.parse(JSON.stringify(slotData.userMoments)); // 加载所有朋友圈动态

                // 立即持久化到IndexedDB
                await putData('userData', userData);
                await putData('friendData', friendData);
                await putData('apiConfig', apiConfig);
                await putData('appSettings', appSettings);
                
                // 清空并重新添加聊天记录
                await clearStore('chatHistory');
                for (const bubble of chatHistoryArray) {
                    await putData('chatHistory', bubble);
                }

                // 清空并重新添加朋友圈动态
                await clearStore('userMoments');
                for (const moment of userMoments) {
                    await putData('userMoments', moment);
                }

                // 更新UI
                updateFriendNameInHeader();
                updateFriendConfigModalUI();
                updateApiFields();
                autoReplySwitch.checked = appSettings.autoReplyEnabled;
                inputAreaShiftUpSwitch.checked = appSettings.inputAreaShiftedUp;
                applyInputAreaShift(appSettings.inputAreaShiftedUp);
                innerVoiceFontSelect.value = appSettings.innerVoiceFont;
                applyInnerVoiceFont(appSettings.innerVoiceFont);
                essayFontSelect.value = appSettings.essayFont;
                applyEssayFont(appSettings.essayFont);
                emojiDisplayModeSelect.value = appSettings.emojiDisplayMode;
                applyTheme(appSettings.currentTheme);
                applyChatBackground(appSettings.chatBackground.type, appSettings.chatBackground.value);
            // 设置CSS变量，用于表情包卡片定位
            document.documentElement.style.setProperty('--input-area-height', `${document.querySelector('.input-area').offsetHeight}px`);
            // 初始化表情包卡片
            renderEmojis();
                
                chatArea.innerHTML = '';
                chatHistoryArray.forEach(bubble => {
                    if (bubble.type === 'event') {
                        addEventMessageToDOM(bubble.content, bubble.messageId);
                    } else {
                        addBubbleToDOM(bubble);
                    }
                });
                userMessageCounter = chatHistoryArray.filter(bubble => bubble.type === 'sent').length;
                scrollToBottom();
                document.getElementById('inner-voice-display').textContent = currentInnerVoice;
                document.getElementById('essay-display').textContent = friendData.currentEssay;
                await updateMomentsDisplay(); // 刷新朋友圈显示

                // 恢复番茄钟状态
                if (appSettings.pomodoro.isActive) {
                    pomodoroGoal = appSettings.pomodoro.goal;
                    pomodoroStartTime = appSettings.pomodoro.startTime;
                    pomodoroEndTime = appSettings.pomodoro.endTime;
                    isPomodoroActive = true;
                    const now = Date.now();
                    if (pomodoroEndTime > now) {
                        resumePomodoroTimer();
                        pomodoroBtn.classList.add('active-pomodoro');
                        pomodoroBtn.title = `番茄钟：${pomodoroGoal} (专注中)`;
                    } else {
                        stopPomodoroTimer('completed'); // 触发完成逻辑
                    }
                } else {
                    // 如果存档中番茄钟不活跃，确保UI也重置
                    if (pomodoroTimer) clearInterval(pomodoroTimer);
                    pomodoroTimer = null;
                    isPomodoroActive = false;
                    pomodoroBtn.classList.remove('active-pomodoro');
                    pomodoroBtn.title = `番茄钟`;
                    pomodoroCountdownDisplay.textContent = '25:00';
                }


                closeModal(localRecordsModal);
                showNotification(`存档位 ${slotId} 已成功恢复！`);
                console.log(`Loaded state from ${slotId}`);

            } catch (error) {
                console.error('恢复存档失败:', error);
                showNotification('恢复存档失败，请检查控制台。');
            }
        }

        async function deleteSlot(slotId) {
            localRecords[slotId] = null;
            await saveLocalRecords();
            await populateLocalRecordsModal(); // 刷新弹窗显示
            showNotification(`存档位 ${slotId} 已删除。`);
        }

        // 初始化应用
        initApp();
    </script>
</body>
</html>